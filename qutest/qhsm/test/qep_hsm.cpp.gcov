        -:    0:Source:../../../../src/qf/qep_hsm.cpp
        -:    0:Graph:build/qep_hsm.gcno
        -:    0:Data:build/qep_hsm.gcda
        -:    0:Runs:6
        -:    1://$file${src::qf::qep_hsm.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:    2://
        -:    3:// Model: qpcpp.qm
        -:    4:// File:  ${src::qf::qep_hsm.cpp}
        -:    5://
        -:    6:// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
        -:    7:// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
        -:    8://
        -:    9:// This generated code is covered by the following QP license:
        -:   10:// License #    : LicenseRef-QL-dual
        -:   11:// Issued to    : General public
        -:   12:// Framework(s) : qpcpp
        -:   13:// Support ends : 2025-12-31
        -:   14://
        -:   15:// Copyright (C) 2005 Quantum Leaps, LLC. All rights reserved.
        -:   16://
        -:   17://                    Q u a n t u m  L e a P s
        -:   18://                    ------------------------
        -:   19://                    Modern Embedded Software
        -:   20://
        -:   21:// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
        -:   22://
        -:   23:// The QP/C++ software is dual-licensed under the terms of the open-source
        -:   24:// GNU General Public License (GPL) or under the terms of one of the closed-
        -:   25:// source Quantum Leaps commercial licenses.
        -:   26://
        -:   27:// Redistributions in source code must retain this top-level comment block.
        -:   28:// Plagiarizing this software to sidestep the license obligations is illegal.
        -:   29://
        -:   30:// NOTE:
        -:   31:// The GPL (see <www.gnu.org/licenses/gpl-3.0>) does NOT permit the
        -:   32:// incorporation of the QP/C++ software into proprietary programs. Please
        -:   33:// contact Quantum Leaps for commercial licensing options, which expressly
        -:   34:// supersede the GPL and are designed explicitly for licensees interested
        -:   35:// in using QP/C++ in closed-source proprietary applications.
        -:   36://
        -:   37:// Quantum Leaps contact information:
        -:   38:// <www.state-machine.com/licensing>
        -:   39:// <info@state-machine.com>
        -:   40://
        -:   41://$endhead${src::qf::qep_hsm.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   42:#define QP_IMPL             // this is QP implementation
        -:   43:#include "qp_port.hpp"      // QP port
        -:   44:#include "qp_pkg.hpp"       // QP package-scope interface
        -:   45:#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
        -:   46:#ifdef Q_SPY                // QS software tracing enabled?
        -:   47:    #include "qs_port.hpp"  // QS port
        -:   48:    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
        -:   49:#else
        -:   50:    #include "qs_dummy.hpp" // disable the QS software tracing
        -:   51:#endif // Q_SPY
        -:   52:
        -:   53://============================================================================
        -:   54://! @cond INTERNAL
        -:   55:
        -:   56:// unnamed namespace for local definitions with internal linkage
        -:   57:namespace {
        -:   58:Q_DEFINE_THIS_MODULE("qep_hsm")
        -:   59:
        -:   60:// immutable events corresponding to the reserved signals.
        -:   61:static QP::QEvt const l_reservedEvt_[4] {
        -:   62:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_EMPTY_SIG)),
        -:   63:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_ENTRY_SIG)),
        -:   64:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_EXIT_SIG)),
        -:   65:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_INIT_SIG))
        -:   66:};
        -:   67:
        -:   68:} // unnamed namespace
        -:   69:
        -:   70:// helper macro to handle reserved event in an QHsm
        -:   71:#define QHSM_RESERVED_EVT_(state_, sig_) \
        -:   72:    ((*(state_))(this, &l_reservedEvt_[(sig_)]))
        -:   73:
        -:   74:// helper macro to trace state entry
        -:   75:#define QS_STATE_ENTRY_(state_, qsId_)         \
        -:   76:    QS_CRIT_ENTRY();                           \
        -:   77:    QS_MEM_SYS();                              \
        -:   78:    QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, (qsId_)) \
        -:   79:        QS_OBJ_PRE_(this);                     \
        -:   80:        QS_FUN_PRE_(state_);                   \
        -:   81:    QS_END_PRE_()                              \
        -:   82:    QS_MEM_APP();                              \
        -:   83:    QS_CRIT_EXIT()
        -:   84:
        -:   85:// helper macro to trace state exit
        -:   86:#define QS_STATE_EXIT_(state_, qsId_)          \
        -:   87:    QS_CRIT_ENTRY();                           \
        -:   88:    QS_MEM_SYS();                              \
        -:   89:    QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, (qsId_))  \
        -:   90:        QS_OBJ_PRE_(this);                     \
        -:   91:        QS_FUN_PRE_(state_);                   \
        -:   92:    QS_END_PRE_()                              \
        -:   93:    QS_MEM_APP();                              \
        -:   94:    QS_CRIT_EXIT()
        -:   95:
        -:   96://! @endcond
        -:   97:
        -:   98:// maximum depth of state nesting in a QHsm (including the top level)
        -:   99:// must be >= 3
        -:  100:static constexpr std::int_fast8_t QHSM_MAX_NEST_DEPTH_ {6};
        -:  101://============================================================================
        -:  102:
        -:  103://$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:  104:// Check for the minimum required QP version
        -:  105:#if (QP_VERSION < 750U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
        -:  106:#error qpcpp version 7.5.0 or higher required
        -:  107:#endif
        -:  108://$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:  109://$define${QEP::versionStr[]} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:  110:namespace QP {
        -:  111:
        -:  112:} // namespace QP
        -:  113://$enddef${QEP::versionStr[]} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:  114:
        -:  115://$define${QEP::QHsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:  116:namespace QP {
        -:  117:
        -:  118://${QEP::QHsm} ...............................................................
        -:  119:
        -:  120://${QEP::QHsm::QHsm} .........................................................
        6:  121:QHsm::QHsm(QStateHandler const initial) noexcept
        6:  122:: QAsm()
        -:  123:{
        6:  124:    m_state.fun = Q_STATE_CAST(&top);
        6:  125:    m_temp.fun  = initial;
        6:  126:}
        -:  127:
        -:  128://${QEP::QHsm::init} .........................................................
        6:  129:void QHsm::init(
        -:  130:    void const * const e,
        -:  131:    std::uint_fast8_t const qsId)
        -:  132:{
        -:  133:    QF_CRIT_STAT
        -:  134:
        6:  135:    QState r;
        -:  136:
        -:  137:    #ifdef Q_SPY
        6:  138:    QS_CRIT_ENTRY();
        6:  139:    QS_MEM_SYS();
        6:  140:    if ((QS::priv_.flags & 0x01U) == 0U) {
        6:  141:        QS::priv_.flags |= 0x01U;
        6:  142:        r = Q_RET_HANDLED;
        -:  143:    }
        -:  144:    else {
        -:  145:        r = Q_RET_IGNORED;
        -:  146:    }
       6*:  147:    QS_MEM_APP();
       6*:  148:    QS_CRIT_EXIT();
    #####:  149:    if (r == Q_RET_HANDLED) {
        6:  150:        QS_FUN_DICTIONARY(&QP::QHsm::top);
        -:  151:    }
        -:  152:    #else
        -:  153:    Q_UNUSED_PAR(qsId);
        -:  154:    #endif // def Q_SPY
        -:  155:
        6:  156:    QStateHandler t = m_state.fun;
        -:  157:
        6:  158:    QF_CRIT_ENTRY();
       6*:  159:    Q_REQUIRE_INCRIT(200, (m_temp.fun != nullptr)
        -:  160:                      && (t == Q_STATE_CAST(&top)));
        6:  161:    QF_CRIT_EXIT();
        -:  162:
        -:  163:    // execute the top-most initial tran.
        6:  164:    r = (*m_temp.fun)(this, Q_EVT_CAST(QEvt));
        -:  165:
        6:  166:    QF_CRIT_ENTRY();
        -:  167:    // the top-most initial tran. must be taken
       6*:  168:    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN);
        -:  169:
        6:  170:    QS_MEM_SYS();
        6:  171:    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  172:        QS_OBJ_PRE_(this);         // this state machine object
        3:  173:        QS_FUN_PRE_(t);            // the source state
        3:  174:        QS_FUN_PRE_(m_temp.fun);   // the target of the initial tran.
        3:  175:    QS_END_PRE_()
        6:  176:    QS_MEM_APP();
        -:  177:
        6:  178:    QF_CRIT_EXIT();
        -:  179:
        -:  180:    // drill down into the state hierarchy with initial transitions...
       12:  181:    do {
       12:  182:        QStateHandler path[QHSM_MAX_NEST_DEPTH_]; // tran. entry path array
       12:  183:        std::int_fast8_t ip = 0; // tran. entry path index
        -:  184:
       12:  185:        path[0] = m_temp.fun;
       12:  186:        static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        -:  187:        // note: ip is here the fixed upper loop bound
       24:  188:        while ((m_temp.fun != t) && (ip < (QHSM_MAX_NEST_DEPTH_ - 1))) {
       12:  189:            ++ip;
       12:  190:            path[ip] = m_temp.fun;
       12:  191:            static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        -:  192:        }
       12:  193:        QF_CRIT_ENTRY();
        -:  194:        // too many state nesting levels or "malformed" HSM
      12*:  195:        Q_ENSURE_INCRIT(220, ip < QHSM_MAX_NEST_DEPTH_);
       12:  196:        QF_CRIT_EXIT();
        -:  197:
       12:  198:        m_temp.fun = path[0];
        -:  199:
        -:  200:        // retrace the entry path in reverse (desired) order...
        -:  201:        // note: ip is the fixed upper loop bound
       24:  202:        do {
        -:  203:            // enter path[ip]
       24:  204:            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  205:                == Q_RET_HANDLED)
        -:  206:            {
       24:  207:                QS_STATE_ENTRY_(path[ip], qsId);
        -:  208:            }
       24:  209:            --ip;
       24:  210:        } while (ip >= 0);
        -:  211:
       12:  212:        t = path[0]; // current state becomes the new source
        -:  213:
       12:  214:        r = QHSM_RESERVED_EVT_(t, Q_INIT_SIG); // execute initial tran.
        -:  215:
        -:  216:    #ifdef Q_SPY
       12:  217:        if (r == Q_RET_TRAN) {
        6:  218:            QS_CRIT_ENTRY();
        6:  219:            QS_MEM_SYS();
        6:  220:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  221:                QS_OBJ_PRE_(this);         // this state machine object
        3:  222:                QS_FUN_PRE_(t);            // the source state
        3:  223:                QS_FUN_PRE_(m_temp.fun);   // the target of the initial tran.
        3:  224:            QS_END_PRE_()
        6:  225:            QS_MEM_APP();
        6:  226:            QS_CRIT_EXIT();
        -:  227:        }
        -:  228:    #endif // Q_SPY
       12:  229:    } while (r == Q_RET_TRAN);
        -:  230:
        6:  231:    QF_CRIT_ENTRY();
        -:  232:
        6:  233:    QS_MEM_SYS();
        6:  234:    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qsId)
        3:  235:        QS_TIME_PRE_();    // time stamp
        3:  236:        QS_OBJ_PRE_(this); // this state machine object
        3:  237:        QS_FUN_PRE_(t);    // the new active state
        3:  238:    QS_END_PRE_()
        6:  239:    QS_MEM_APP();
        -:  240:
        6:  241:    QF_CRIT_EXIT();
        -:  242:
        6:  243:    m_state.fun = t;   // change the current active state
        -:  244:    #ifndef Q_UNSAFE
        6:  245:    m_temp.uint = ~m_state.uint;
        -:  246:    #endif
        6:  247:}
        -:  248:
        -:  249://${QEP::QHsm::dispatch} .....................................................
       41:  250:void QHsm::dispatch(
        -:  251:    QEvt const * const e,
        -:  252:    std::uint_fast8_t const qsId)
        -:  253:{
        -:  254:    #ifndef Q_SPY
        -:  255:    Q_UNUSED_PAR(qsId);
        -:  256:    #endif
        -:  257:
       41:  258:    QStateHandler s = m_state.fun;
       41:  259:    QStateHandler t = s;
        -:  260:    QF_CRIT_STAT
        -:  261:
       41:  262:    QF_CRIT_ENTRY();
      41*:  263:    Q_REQUIRE_INCRIT(300, QEvt::verify_(e));
      41*:  264:    Q_INVARIANT_INCRIT(302, (s != Q_STATE_CAST(0))
        -:  265:        && (m_state.uint == static_cast<std::uintptr_t>(~m_temp.uint)));
        -:  266:
       41:  267:    QS_MEM_SYS();
       41:  268:    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qsId)
       21:  269:        QS_TIME_PRE_();      // time stamp
       21:  270:        QS_SIG_PRE_(e->sig); // the signal of the event
       21:  271:        QS_OBJ_PRE_(this);   // this state machine object
       21:  272:        QS_FUN_PRE_(s);      // the current state
       21:  273:    QS_END_PRE_()
       41:  274:    QS_MEM_APP();
        -:  275:
       41:  276:    QF_CRIT_EXIT();
        -:  277:
        -:  278:    // process the event hierarchically...
       41:  279:    QState r;
       41:  280:    m_temp.fun = s;
       41:  281:    std::int_fast8_t ip = QHSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       93:  282:    do {
       93:  283:        s = m_temp.fun;
       93:  284:        r = (*s)(this, e); // invoke state handler s
        -:  285:
       93:  286:        if (r == Q_RET_UNHANDLED) { // unhandled due to a guard?
        -:  287:
        4:  288:            QS_CRIT_ENTRY();
        4:  289:            QS_MEM_SYS();
        4:  290:            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qsId)
        2:  291:                QS_SIG_PRE_(e->sig); // the signal of the event
        2:  292:                QS_OBJ_PRE_(this);   // this state machine object
        2:  293:                QS_FUN_PRE_(s);      // the current state
        2:  294:            QS_END_PRE_()
        4:  295:            QS_MEM_APP();
        4:  296:            QS_CRIT_EXIT();
        -:  297:
        4:  298:            r = QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG); // superstate of s
        -:  299:        }
        -:  300:
       93:  301:        --ip;
       93:  302:    } while ((r == Q_RET_SUPER) && (ip > 0));
        -:  303:
       41:  304:    QF_CRIT_ENTRY();
      41*:  305:    Q_ENSURE_INCRIT(310, ip > 0);
       41:  306:    QF_CRIT_EXIT();
        -:  307:
       41:  308:    if (r >= Q_RET_TRAN) { // tran. (regular or history) taken?
        -:  309:    #ifdef Q_SPY
       34:  310:        if (r == Q_RET_TRAN_HIST) { // tran. to history?
        8:  311:            QS_CRIT_ENTRY();
        8:  312:            QS_MEM_SYS();
        8:  313:            QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qsId)
        4:  314:                QS_OBJ_PRE_(this); // this state machine object
        4:  315:                QS_FUN_PRE_(s);          // tran. to history source
        4:  316:                QS_FUN_PRE_(m_temp.fun); // tran. to history target
        4:  317:            QS_END_PRE_()
        8:  318:            QS_MEM_APP();
        8:  319:            QS_CRIT_EXIT();
        -:  320:        }
        -:  321:    #endif // Q_SPY
        -:  322:
       34:  323:        QStateHandler path[QHSM_MAX_NEST_DEPTH_];
       34:  324:        path[0] = m_temp.fun; // tran. target
       34:  325:        path[1] = t; // current state
       34:  326:        path[2] = s; // tran. source
        -:  327:
        -:  328:        // exit current state to tran. source s...
       34:  329:        ip = QHSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       64:  330:        for (; (t != s) && (ip > 0); t = m_temp.fun) {
        -:  331:            // exit from t
       30:  332:            if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG) == Q_RET_HANDLED) {
       30:  333:                QS_STATE_EXIT_(t, qsId);
        -:  334:                // find superstate of t
       30:  335:                static_cast<void>(QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
        -:  336:            }
       30:  337:            --ip;
        -:  338:        }
       34:  339:        QF_CRIT_ENTRY();
      34*:  340:        Q_ENSURE_INCRIT(320, ip > 0);
       34:  341:        QF_CRIT_EXIT();
        -:  342:
       34:  343:        ip = hsm_tran(path, qsId); // take the tran.
        -:  344:
        -:  345:        // execute state entry actions in the desired order...
        -:  346:        // note: ip is the fixed upper loop bound
       78:  347:        for (; ip >= 0; --ip) {
        -:  348:            // enter path[ip]
       44:  349:            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  350:                == Q_RET_HANDLED)
        -:  351:            {
       44:  352:                QS_STATE_ENTRY_(path[ip], qsId);
        -:  353:            }
        -:  354:        }
       34:  355:        t = path[0];    // stick the target into register
       34:  356:        m_temp.fun = t; // update the next state
        -:  357:
        -:  358:        // drill into the target hierarchy...
       50:  359:        while (QHSM_RESERVED_EVT_(t, Q_INIT_SIG) == Q_RET_TRAN) {
        -:  360:
       16:  361:            QS_CRIT_ENTRY();
       16:  362:            QS_MEM_SYS();
       16:  363:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        8:  364:                QS_OBJ_PRE_(this);         // this state machine object
        8:  365:                QS_FUN_PRE_(t);            // the source (pseudo)state
        8:  366:                QS_FUN_PRE_(m_temp.fun);   // the target of the tran.
        8:  367:            QS_END_PRE_()
       16:  368:            QS_MEM_APP();
       16:  369:            QS_CRIT_EXIT();
        -:  370:
       16:  371:            ip = 0;
       16:  372:            path[0] = m_temp.fun;
        -:  373:
        -:  374:            // find superstate
       16:  375:            static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        -:  376:
        -:  377:            // note: ip is the fixed upper loop bound
       24:  378:            while ((m_temp.fun != t) && (ip < (QHSM_MAX_NEST_DEPTH_ - 1))) {
        8:  379:                ++ip;
        8:  380:                path[ip] = m_temp.fun;
        -:  381:                // find superstate
        8:  382:                static_cast<void>(
        8:  383:                    QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        -:  384:            }
       16:  385:            QF_CRIT_ENTRY();
        -:  386:            // too many state nesting levels or "malformed" HSM
      16*:  387:            Q_ENSURE_INCRIT(330, ip < QHSM_MAX_NEST_DEPTH_);
       16:  388:            QF_CRIT_EXIT();
        -:  389:
       16:  390:            m_temp.fun = path[0];
        -:  391:
        -:  392:            // retrace the entry path in reverse (correct) order...
        -:  393:            // note: ip is the fixed upper loop bound
       24:  394:            do {
        -:  395:                // enter path[ip]
       24:  396:                if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  397:                    == Q_RET_HANDLED)
        -:  398:                {
       24:  399:                    QS_STATE_ENTRY_(path[ip], qsId);
        -:  400:                }
       24:  401:                --ip;
       24:  402:            } while (ip >= 0);
        -:  403:
       16:  404:            t = path[0]; // current state becomes the new source
        -:  405:        }
        -:  406:
       34:  407:        QS_CRIT_ENTRY();
       34:  408:        QS_MEM_SYS();
       34:  409:        QS_BEGIN_PRE_(QS_QEP_TRAN, qsId)
       17:  410:            QS_TIME_PRE_();      // time stamp
       17:  411:            QS_SIG_PRE_(e->sig); // the signal of the event
       17:  412:            QS_OBJ_PRE_(this);   // this state machine object
       17:  413:            QS_FUN_PRE_(s);      // the source of the tran.
       17:  414:            QS_FUN_PRE_(t);      // the new active state
       17:  415:        QS_END_PRE_()
       34:  416:        QS_MEM_APP();
       34:  417:        QS_CRIT_EXIT();
        -:  418:    }
        -:  419:
        -:  420:    #ifdef Q_SPY
        7:  421:    else if (r == Q_RET_HANDLED) {
        4:  422:        QS_CRIT_ENTRY();
        4:  423:        QS_MEM_SYS();
        4:  424:        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qsId)
        2:  425:            QS_TIME_PRE_();      // time stamp
        2:  426:            QS_SIG_PRE_(e->sig); // the signal of the event
        2:  427:            QS_OBJ_PRE_(this);   // this state machine object
        2:  428:            QS_FUN_PRE_(s);      // the source state
        2:  429:        QS_END_PRE_()
        4:  430:        QS_MEM_APP();
        4:  431:        QS_CRIT_EXIT();
        -:  432:    }
        -:  433:    else {
        3:  434:        QS_CRIT_ENTRY();
        3:  435:        QS_MEM_SYS();
        3:  436:        QS_BEGIN_PRE_(QS_QEP_IGNORED, qsId)
        2:  437:            QS_TIME_PRE_();      // time stamp
        2:  438:            QS_SIG_PRE_(e->sig); // the signal of the event
        2:  439:            QS_OBJ_PRE_(this);   // this state machine object
        2:  440:            QS_FUN_PRE_(m_state.fun); // the current state
        2:  441:        QS_END_PRE_()
        3:  442:        QS_MEM_APP();
        3:  443:        QS_CRIT_EXIT();
        -:  444:    }
        -:  445:    #endif // Q_SPY
        -:  446:
       41:  447:    m_state.fun = t; // change the current active state
        -:  448:    #ifndef Q_UNSAFE
       41:  449:    m_temp.uint = ~m_state.uint;
        -:  450:    #endif
       41:  451:}
        -:  452:
        -:  453://${QEP::QHsm::isIn} .........................................................
       11:  454:bool QHsm::isIn(QStateHandler const state) noexcept {
        -:  455:    QF_CRIT_STAT
       11:  456:    QF_CRIT_ENTRY();
      11*:  457:    Q_INVARIANT_INCRIT(602, m_state.uint
        -:  458:                       == static_cast<std::uintptr_t>(~m_temp.uint));
       11:  459:    QF_CRIT_EXIT();
        -:  460:
       11:  461:    bool inState = false; // assume that this HSM is not in 'state'
        -:  462:
        -:  463:    // scan the state hierarchy bottom-up
       11:  464:    QStateHandler s = m_state.fun;
       11:  465:    std::int_fast8_t lbound = QHSM_MAX_NEST_DEPTH_ + 1; // fixed upper loop bound
       11:  466:    QState r = Q_RET_SUPER;
       29:  467:    for (; (r != Q_RET_IGNORED) && (lbound > 0); --lbound) {
       26:  468:        if (s == state) { // do the states match?
        -:  469:            inState = true;  // 'true' means that match found
        -:  470:            break; // break out of the for-loop
        -:  471:        }
        -:  472:        else {
       18:  473:            r = QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG);
       18:  474:            s = m_temp.fun;
        -:  475:        }
        -:  476:    }
        -:  477:
       11:  478:    QF_CRIT_ENTRY();
      11*:  479:    Q_ENSURE_INCRIT(690, lbound > 0);
       11:  480:    QF_CRIT_EXIT();
        -:  481:
        -:  482:    #ifndef Q_UNSAFE
       11:  483:    m_temp.uint = ~m_state.uint;
        -:  484:    #endif
        -:  485:
       11:  486:    return inState; // return the status
        -:  487:}
        -:  488:
        -:  489://${QEP::QHsm::childState} ...................................................
       10:  490:QStateHandler QHsm::childState(QStateHandler const parent) noexcept {
       10:  491:    QStateHandler child = m_state.fun; // start with current state
       10:  492:    bool isFound = false; // start with the child not found
        -:  493:
        -:  494:    // establish stable state configuration
       10:  495:    m_temp.fun = child;
       10:  496:    QState r;
       10:  497:    std::int_fast8_t lbound = QHSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       34:  498:    do {
        -:  499:        // is this the parent of the current child?
       34:  500:        if (m_temp.fun == parent) {
        -:  501:            isFound = true; // child is found
        -:  502:            r = Q_RET_IGNORED; // break out of the loop
        -:  503:        }
        -:  504:        else {
       24:  505:            child = m_temp.fun;
       24:  506:            r = QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG);
        -:  507:        }
       34:  508:        --lbound;
       34:  509:    } while ((r != Q_RET_IGNORED)  // QHsm::top() state not reached
       34:  510:             && (lbound > 0));
        -:  511:
        -:  512:    #ifndef Q_UNSAFE
       10:  513:    m_temp.uint = ~m_state.uint;
        -:  514:    #else
        -:  515:    Q_UNUSED_PAR(isFound);
        -:  516:    #endif
        -:  517:
        -:  518:    QF_CRIT_STAT
       10:  519:    QF_CRIT_ENTRY();
        -:  520:    // NOTE: the following postcondition can only succeed when
        -:  521:    // (lbound > 0), so no extra check is necessary.
      10*:  522:    Q_ENSURE_INCRIT(890, isFound);
       10:  523:    QF_CRIT_EXIT();
        -:  524:
       10:  525:    return child;
        -:  526:}
        -:  527:
        -:  528://${QEP::QHsm::hsm_tran} .....................................................
       34:  529:std::int_fast8_t QHsm::hsm_tran(
        -:  530:    QStateHandler * const path,
        -:  531:    std::uint_fast8_t const qsId)
        -:  532:{
        -:  533:    #ifndef Q_SPY
        -:  534:    Q_UNUSED_PAR(qsId);
        -:  535:    #endif
        -:  536:
       34:  537:    std::int_fast8_t ip = -1; // tran. entry path index
       34:  538:    QStateHandler t = path[0];
       34:  539:    QStateHandler const s = path[2];
        -:  540:    QF_CRIT_STAT
        -:  541:
        -:  542:    // (a) check source==target (tran. to self)...
       34:  543:    if (s == t) {
        -:  544:        // exit source s
        2:  545:        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
        2:  546:            QS_STATE_EXIT_(s, qsId);
        -:  547:        }
        2:  548:        ip = 0; // enter the target
        -:  549:    }
        -:  550:    else {
        -:  551:        // find superstate of target
       32:  552:        static_cast<void>(QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
        -:  553:
       32:  554:        t = m_temp.fun;
        -:  555:
        -:  556:        // (b) check source==target->super...
       32:  557:        if (s == t) {
        -:  558:            ip = 0; // enter the target
        -:  559:        }
        -:  560:        else {
        -:  561:            // find superstate of src
       28:  562:            static_cast<void>(QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG));
        -:  563:
        -:  564:            // (c) check source->super==target->super...
       28:  565:            if (m_temp.fun == t) {
        -:  566:                // exit source s
       12:  567:                if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
       12:  568:                    QS_STATE_EXIT_(s, qsId);
        -:  569:                }
       12:  570:                ip = 0; // enter the target
        -:  571:            }
        -:  572:            else {
        -:  573:                // (d) check source->super==target...
       16:  574:                if (m_temp.fun == path[0]) {
        -:  575:                    // exit source s
        4:  576:                    if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
        4:  577:                        QS_STATE_EXIT_(s, qsId);
        -:  578:                    }
        -:  579:                }
        -:  580:                else {
        -:  581:                    // (e) check rest of source==target->super->super..
        -:  582:                    // and store the entry path along the way
       12:  583:                    std::int_fast8_t iq = 0; // indicate that LCA was found
       12:  584:                    ip = 1; // enter target and its superstate
       12:  585:                    path[1] = t;      // save the superstate of target
       12:  586:                    t = m_temp.fun;   // save source->super
        -:  587:
        -:  588:                    // find target->super->super...
        -:  589:                    // note: ip is the fixed upper loop bound
       12:  590:                    QState r = QHSM_RESERVED_EVT_(path[1], Q_EMPTY_SIG);
       34:  591:                    while ((r == Q_RET_SUPER)
       34:  592:                           && (ip < (QHSM_MAX_NEST_DEPTH_ - 1)))
        -:  593:                    {
       22:  594:                        ++ip;
       22:  595:                        path[ip] = m_temp.fun; // store the entry path
       22:  596:                        if (m_temp.fun == s) { // is it the source?
        -:  597:                            iq = 1; // indicate that the LCA found
        -:  598:                            --ip; // do not enter the source
        -:  599:                            r = Q_RET_HANDLED; // terminate the loop
        -:  600:                        }
        -:  601:                        else { // it is not the source, keep going up
       22:  602:                            r = QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG);
        -:  603:                        }
        -:  604:                    }
       12:  605:                    QF_CRIT_ENTRY();
        -:  606:                    // NOTE: The following postcondition succeeds only when
        -:  607:                    // ip < QHSM_MAX_NEST_DEPTH, so no additional check is necessary
        -:  608:                    // too many state nesting levels or "malformed" HSM.
      12*:  609:                    Q_ENSURE_INCRIT(510, r != Q_RET_SUPER);
       12:  610:                    QF_CRIT_EXIT();
        -:  611:
        -:  612:                    // the LCA not found yet?
       12:  613:                    if (iq == 0) {
        -:  614:                        // exit source s
       12:  615:                        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG)
        -:  616:                            == Q_RET_HANDLED)
        -:  617:                        {
       12:  618:                            QS_STATE_EXIT_(s, qsId);
        -:  619:                        }
        -:  620:
        -:  621:                        // (f) check the rest of source->super
        -:  622:                        //                  == target->super->super...
       12:  623:                        iq = ip;
       12:  624:                        r = Q_RET_IGNORED; // indicate that the LCA NOT found
        -:  625:                        // note: iq is the fixed upper loop bound
       30:  626:                        do {
       30:  627:                            if (t == path[iq]) { // is this the LCA?
        6:  628:                                r = Q_RET_HANDLED; // indicate the LCA found
        6:  629:                                ip = iq - 1; // do not enter the LCA
        6:  630:                                iq = -1; // cause termination of the loop
        -:  631:                            }
        -:  632:                            else {
       24:  633:                                --iq; // try lower superstate of target
        -:  634:                            }
       30:  635:                        } while (iq >= 0);
        -:  636:
        -:  637:                        // the LCA not found yet?
       12:  638:                        if (r != Q_RET_HANDLED) {
        -:  639:                            // (g) check each source->super->...
        -:  640:                            // for each target->super...
        -:  641:                            r = Q_RET_IGNORED; // keep looping
        -:  642:                            std::int_fast8_t lbound = QHSM_MAX_NEST_DEPTH_;
        8:  643:                            do {
        -:  644:                                // exit from t
        8:  645:                                if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG)
        -:  646:                                    == Q_RET_HANDLED)
        -:  647:                                {
        8:  648:                                    QS_STATE_EXIT_(t, qsId);
        -:  649:                                    // find superstate of t
        8:  650:                                    static_cast<void>(
        8:  651:                                        QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
        -:  652:                                }
        8:  653:                                t = m_temp.fun; // set to super of t
        8:  654:                                iq = ip;
       16:  655:                                do {
        -:  656:                                    // is this the LCA?
       16:  657:                                    if (t == path[iq]) {
        6:  658:                                        ip = iq - 1; // do not enter the LCA
        6:  659:                                        iq = -1;     // break out of inner loop
        6:  660:                                        r = Q_RET_HANDLED; // break outer loop
        -:  661:                                    }
        -:  662:                                    else {
       10:  663:                                        --iq;
        -:  664:                                    }
       16:  665:                                } while (iq >= 0);
        -:  666:
        8:  667:                                --lbound;
        8:  668:                            } while ((r != Q_RET_HANDLED) && (lbound > 0));
        6:  669:                            QF_CRIT_ENTRY();
       6*:  670:                            Q_ENSURE_INCRIT(530, lbound > 0);
        6:  671:                            QF_CRIT_EXIT();
        -:  672:                        }
        -:  673:                    }
        -:  674:                }
        -:  675:            }
        -:  676:        }
        -:  677:    }
      12*:  678:    QF_CRIT_ENTRY();
      34*:  679:    Q_ENSURE_INCRIT(590, ip < QHSM_MAX_NEST_DEPTH_);
       34:  680:    QF_CRIT_EXIT();
       34:  681:    return ip;
        -:  682:}
        -:  683:
        -:  684:} // namespace QP
        -:  685://$enddef${QEP::QHsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
