        -:    0:Source:../../../../src/qf/qep_hsm.cpp
        -:    0:Graph:build/qep_hsm.gcno
        -:    0:Data:build/qep_hsm.gcda
        -:    0:Runs:3
        -:    1://$file${src::qf::qep_hsm.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:    2://
        -:    3:// Model: qpcpp.qm
        -:    4:// File:  ${src::qf::qep_hsm.cpp}
        -:    5://
        -:    6:// This code has been generated by QM 6.1.1 <www.state-machine.com/qm>.
        -:    7:// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
        -:    8://
        -:    9:// This code is covered by the following QP license:
        -:   10:// License #    : LicenseRef-QL-dual
        -:   11:// Issued to    : Any user of the QP/C++ real-time embedded framework
        -:   12:// Framework(s) : qpcpp
        -:   13:// Support ends : 2024-12-31
        -:   14:// License scope:
        -:   15://
        -:   16:// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
        -:   17://
        -:   18://                    Q u a n t u m  L e a P s
        -:   19://                    ------------------------
        -:   20://                    Modern Embedded Software
        -:   21://
        -:   22:// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
        -:   23://
        -:   24:// This software is dual-licensed under the terms of the open source GNU
        -:   25:// General Public License version 3 (or any later version), or alternatively,
        -:   26:// under the terms of one of the closed source Quantum Leaps commercial
        -:   27:// licenses.
        -:   28://
        -:   29:// The terms of the open source GNU General Public License version 3
        -:   30:// can be found at: <www.gnu.org/licenses/gpl-3.0>
        -:   31://
        -:   32:// The terms of the closed source Quantum Leaps commercial licenses
        -:   33:// can be found at: <www.state-machine.com/licensing>
        -:   34://
        -:   35:// Redistributions in source code must retain this top-level comment block.
        -:   36:// Plagiarizing this software to sidestep the license obligations is illegal.
        -:   37://
        -:   38:// Contact information:
        -:   39:// <www.state-machine.com/licensing>
        -:   40:// <info@state-machine.com>
        -:   41://
        -:   42://$endhead${src::qf::qep_hsm.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   43:#define QP_IMPL             // this is QP implementation
        -:   44:#include "qp_port.hpp"      // QP port
        -:   45:#include "qp_pkg.hpp"       // QP package-scope interface
        -:   46:#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
        -:   47:#ifdef Q_SPY                // QS software tracing enabled?
        -:   48:    #include "qs_port.hpp"  // QS port
        -:   49:    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
        -:   50:#else
        -:   51:    #include "qs_dummy.hpp" // disable the QS software tracing
        -:   52:#endif // Q_SPY
        -:   53:
        -:   54://============================================================================
        -:   55://! @cond INTERNAL
        -:   56:
        -:   57:// unnamed namespace for local definitions with internal linkage
        -:   58:namespace {
        -:   59:Q_DEFINE_THIS_MODULE("qep_hsm")
        -:   60:
        -:   61:// immutable events corresponding to the reserved signals.
        -:   62:static QP::QEvt const l_reservedEvt_[4] {
        -:   63:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_EMPTY_SIG)),
        -:   64:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_ENTRY_SIG)),
        -:   65:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_EXIT_SIG)),
        -:   66:    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_INIT_SIG))
        -:   67:};
        -:   68:
        -:   69:} // unnamed namespace
        -:   70:
        -:   71:// helper macro to handle reserved event in an QHsm
        -:   72:#define QHSM_RESERVED_EVT_(state_, sig_) \
        -:   73:    ((*(state_))(this, &l_reservedEvt_[(sig_)]))
        -:   74:
        -:   75:// helper macro to trace state entry
        -:   76:#define QS_STATE_ENTRY_(state_, qsId_)         \
        -:   77:    QS_CRIT_ENTRY();                           \
        -:   78:    QS_MEM_SYS();                              \
        -:   79:    QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, (qsId_)) \
        -:   80:        QS_OBJ_PRE_(this);                     \
        -:   81:        QS_FUN_PRE_(state_);                   \
        -:   82:    QS_END_PRE_()                              \
        -:   83:    QS_MEM_APP();                              \
        -:   84:    QS_CRIT_EXIT()
        -:   85:
        -:   86:// helper macro to trace state exit
        -:   87:#define QS_STATE_EXIT_(state_, qsId_)          \
        -:   88:    QS_CRIT_ENTRY();                           \
        -:   89:    QS_MEM_SYS();                              \
        -:   90:    QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, (qsId_))  \
        -:   91:        QS_OBJ_PRE_(this);                     \
        -:   92:        QS_FUN_PRE_(state_);                   \
        -:   93:    QS_END_PRE_()                              \
        -:   94:    QS_MEM_APP();                              \
        -:   95:    QS_CRIT_EXIT()
        -:   96:
        -:   97://! @endcond
        -:   98://============================================================================
        -:   99:
        -:  100://$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:  101:// Check for the minimum required QP version
        -:  102:#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
        -:  103:#error qpcpp version 7.3.0 or higher required
        -:  104:#endif
        -:  105://$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:  106:
        -:  107://$define${QEP::versionStr[]} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:  108:namespace QP {
        -:  109:
        -:  110:} // namespace QP
        -:  111://$enddef${QEP::versionStr[]} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:  112:
        -:  113://$define${QEP::QHsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:  114:namespace QP {
        -:  115:
        -:  116://${QEP::QHsm} ...............................................................
        -:  117:
        -:  118://${QEP::QHsm::QHsm} .........................................................
        3:  119:QHsm::QHsm(QStateHandler const initial) noexcept
        3:  120:: QAsm()
        -:  121:{
        3:  122:    m_state.fun = Q_STATE_CAST(&top);
        3:  123:    m_temp.fun  = initial;
        3:  124:}
        -:  125:
        -:  126://${QEP::QHsm::init} .........................................................
        3:  127:void QHsm::init(
        -:  128:    void const * const e,
        -:  129:    std::uint_fast8_t const qsId)
        -:  130:{
        -:  131:    QF_CRIT_STAT
        -:  132:
        -:  133:    #ifdef Q_SPY
        3:  134:    QS_CRIT_ENTRY();
        3:  135:    QS_MEM_SYS();
        3:  136:    if ((QS::priv_.flags & 0x01U) == 0U) {
        3:  137:        QS::priv_.flags |= 0x01U;
        3:  138:        QS_MEM_APP();
        3:  139:        QS_CRIT_EXIT();
        3:  140:        QS_FUN_DICTIONARY(&QP::QHsm::top);
        -:  141:    }
        -:  142:    else {
    #####:  143:        QS_MEM_APP();
    #####:  144:        QS_CRIT_EXIT();
        -:  145:    }
        -:  146:    #else
        -:  147:    Q_UNUSED_PAR(qsId);
        -:  148:    #endif
        -:  149:
        3:  150:    QStateHandler t = m_state.fun;
        -:  151:
        3:  152:    QF_CRIT_ENTRY();
       3*:  153:    Q_REQUIRE_INCRIT(200, (m_temp.fun != nullptr)
        -:  154:                      && (t == Q_STATE_CAST(&top)));
        3:  155:    QF_CRIT_EXIT();
        -:  156:
        -:  157:    // execute the top-most initial tran.
        3:  158:    QState r = (*m_temp.fun)(this, Q_EVT_CAST(QEvt));
        -:  159:
        3:  160:    QF_CRIT_ENTRY();
        -:  161:    // the top-most initial tran. must be taken
       3*:  162:    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN);
        -:  163:
        3:  164:    QS_MEM_SYS();
        3:  165:    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  166:        QS_OBJ_PRE_(this);         // this state machine object
        3:  167:        QS_FUN_PRE_(t);            // the source state
        3:  168:        QS_FUN_PRE_(m_temp.fun);   // the target of the initial tran.
        3:  169:    QS_END_PRE_()
        3:  170:    QS_MEM_APP();
        -:  171:
        3:  172:    QF_CRIT_EXIT();
        -:  173:
        -:  174:    // drill down into the state hierarchy with initial transitions...
        3:  175:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
        6:  176:    do {
        6:  177:        QStateHandler path[MAX_NEST_DEPTH_]; // tran entry path array
        6:  178:        std::int_fast8_t ip = 0; // tran entry path index
        -:  179:
        6:  180:        path[0] = m_temp.fun;
        6:  181:        static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
       12:  182:        while (m_temp.fun != t) {
        6:  183:            ++ip;
        6:  184:            path[ip] = m_temp.fun;
        6:  185:            static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        -:  186:        }
        6:  187:        QF_CRIT_ENTRY();
        -:  188:        // The initial transition source state must be reached
        -:  189:        // Too many state nesting levels or "malformed" HSM.
       6*:  190:        Q_ASSERT_INCRIT(220, m_temp.fun == t);
        6:  191:        QF_CRIT_EXIT();
        -:  192:
        6:  193:        m_temp.fun = path[0];
        -:  194:
        -:  195:        // retrace the entry path in reverse (desired) order...
       12:  196:        do {
        -:  197:            // enter path[ip]
       12:  198:            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  199:                == Q_RET_HANDLED)
        -:  200:            {
       12:  201:                QS_STATE_ENTRY_(path[ip], qsId);
        -:  202:            }
       12:  203:            --ip;
       12:  204:        } while (ip >= 0);
        -:  205:
        6:  206:        t = path[0]; // current state becomes the new source
        -:  207:
        6:  208:        r = QHSM_RESERVED_EVT_(t, Q_INIT_SIG); // execute initial tran.
        -:  209:
        -:  210:    #ifdef Q_SPY
        6:  211:        if (r == Q_RET_TRAN) {
        3:  212:            QS_CRIT_ENTRY();
        3:  213:            QS_MEM_SYS();
        3:  214:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  215:                QS_OBJ_PRE_(this);         // this state machine object
        3:  216:                QS_FUN_PRE_(t);            // the source state
        3:  217:                QS_FUN_PRE_(m_temp.fun);   // the target of the initial tran.
        3:  218:            QS_END_PRE_()
        3:  219:            QS_MEM_APP();
        3:  220:            QS_CRIT_EXIT();
        -:  221:        }
        -:  222:    #endif // Q_SPY
        -:  223:
        6:  224:        --limit;
        6:  225:    } while ((r == Q_RET_TRAN) && (limit > 0));
        -:  226:
        3:  227:    QF_CRIT_ENTRY();
        -:  228:    // Loop limit must not be reached.
        -:  229:    // Too many state nesting levels or likely "malformed" HSM
       3*:  230:    Q_ENSURE_INCRIT(290, limit > 0);
        -:  231:
        3:  232:    QS_MEM_SYS();
        3:  233:    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qsId)
        3:  234:        QS_TIME_PRE_();    // time stamp
        3:  235:        QS_OBJ_PRE_(this); // this state machine object
        3:  236:        QS_FUN_PRE_(t);    // the new active state
        3:  237:    QS_END_PRE_()
        3:  238:    QS_MEM_APP();
        -:  239:
        3:  240:    QF_CRIT_EXIT();
        -:  241:
        3:  242:    m_state.fun = t;   // change the current active state
        -:  243:    #ifndef Q_UNSAFE
        3:  244:    m_temp.uint = ~m_state.uint;
        -:  245:    #endif
        3:  246:}
        -:  247:
        -:  248://${QEP::QHsm::dispatch} .....................................................
       18:  249:void QHsm::dispatch(
        -:  250:    QEvt const * const e,
        -:  251:    std::uint_fast8_t const qsId)
        -:  252:{
        -:  253:    #ifndef Q_SPY
        -:  254:    Q_UNUSED_PAR(qsId);
        -:  255:    #endif
        -:  256:
       18:  257:    QStateHandler s = m_state.fun;
       18:  258:    QStateHandler t = s;
        -:  259:    QF_CRIT_STAT
        -:  260:
       18:  261:    QF_CRIT_ENTRY();
      18*:  262:    Q_REQUIRE_INCRIT(300, (s != Q_STATE_CAST(0))
        -:  263:        && (m_state.uint == static_cast<std::uintptr_t>(~m_temp.uint)));
      18*:  264:    Q_REQUIRE_INCRIT(302, QEvt::verify_(e));
        -:  265:
       18:  266:    QS_MEM_SYS();
       18:  267:    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qsId)
       18:  268:        QS_TIME_PRE_();      // time stamp
       18:  269:        QS_SIG_PRE_(e->sig); // the signal of the event
       18:  270:        QS_OBJ_PRE_(this);   // this state machine object
       18:  271:        QS_FUN_PRE_(s);      // the current state
       18:  272:    QS_END_PRE_()
       18:  273:    QS_MEM_APP();
        -:  274:
       18:  275:    QF_CRIT_EXIT();
        -:  276:
        -:  277:    // process the event hierarchically...
       18:  278:    QState r;
       18:  279:    m_temp.fun = s;
       18:  280:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
       43:  281:    do {
       43:  282:        s = m_temp.fun;
       43:  283:        r = (*s)(this, e); // invoke state handler s
        -:  284:
       43:  285:        if (r == Q_RET_UNHANDLED) { // unhandled due to a guard?
        -:  286:
        2:  287:            QS_CRIT_ENTRY();
        2:  288:            QS_MEM_SYS();
        2:  289:            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qsId)
        2:  290:                QS_SIG_PRE_(e->sig); // the signal of the event
        2:  291:                QS_OBJ_PRE_(this);   // this state machine object
        2:  292:                QS_FUN_PRE_(s);      // the current state
        2:  293:            QS_END_PRE_()
        2:  294:            QS_MEM_APP();
        2:  295:            QS_CRIT_EXIT();
        -:  296:
        2:  297:            r = QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG); // superstate of s
        -:  298:        }
        -:  299:
       43:  300:        --limit;
       43:  301:    } while ((r == Q_RET_SUPER) && (limit > 0));
        -:  302:
       18:  303:    QF_CRIT_ENTRY();
      18*:  304:    Q_ASSERT_INCRIT(310, limit > 0);
       18:  305:    QF_CRIT_EXIT();
        -:  306:
       18:  307:    if (r >= Q_RET_TRAN) { // regular tran. taken?
       14:  308:        QStateHandler path[MAX_NEST_DEPTH_];
        -:  309:
       14:  310:        path[0] = m_temp.fun; // tran. target
       14:  311:        path[1] = t; // current state
       14:  312:        path[2] = s; // tran. source
        -:  313:
        -:  314:        // exit current state to tran. source s...
       14:  315:        limit = MAX_NEST_DEPTH_; // loop hard limit
       26:  316:        for (; (t != s) && (limit > 0); t = m_temp.fun) {
        -:  317:            // exit from t
       12:  318:            if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG) == Q_RET_HANDLED) {
       12:  319:                QS_STATE_EXIT_(t, qsId);
        -:  320:                // find superstate of t
       12:  321:                static_cast<void>(QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
        -:  322:            }
       12:  323:            --limit;
        -:  324:        }
       14:  325:        QF_CRIT_ENTRY();
      14*:  326:        Q_ASSERT_INCRIT(320, limit > 0);
       14:  327:        QF_CRIT_EXIT();
        -:  328:
       14:  329:        std::int_fast8_t ip = hsm_tran(path, qsId); // take the tran.
        -:  330:
        -:  331:    #ifdef Q_SPY
       14:  332:        if (r == Q_RET_TRAN_HIST) {
        3:  333:            QS_CRIT_ENTRY();
        3:  334:            QS_MEM_SYS();
        3:  335:            QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qsId)
        3:  336:                QS_OBJ_PRE_(this);    // this state machine object
        3:  337:                QS_FUN_PRE_(t);       // the source of the transition
        3:  338:                QS_FUN_PRE_(path[0]); // the target of the tran. to history
        3:  339:            QS_END_PRE_()
        3:  340:            QS_MEM_APP();
        3:  341:            QS_CRIT_EXIT();
        -:  342:        }
        -:  343:    #endif // Q_SPY
        -:  344:
        -:  345:        // execute state entry actions in the desired order...
       31:  346:        for (; ip >= 0; --ip) {
        -:  347:            // enter path[ip]
       17:  348:            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  349:                == Q_RET_HANDLED)
        -:  350:            {
       17:  351:                QS_STATE_ENTRY_(path[ip], qsId);
        -:  352:            }
        -:  353:        }
       14:  354:        t = path[0];    // stick the target into register
       14:  355:        m_temp.fun = t; // update the next state
        -:  356:
        -:  357:        // drill into the target hierarchy...
       21:  358:        while (QHSM_RESERVED_EVT_(t, Q_INIT_SIG) == Q_RET_TRAN) {
        -:  359:
        7:  360:            QS_CRIT_ENTRY();
        7:  361:            QS_MEM_SYS();
        7:  362:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        7:  363:                QS_OBJ_PRE_(this);         // this state machine object
        7:  364:                QS_FUN_PRE_(t);            // the source (pseudo)state
        7:  365:                QS_FUN_PRE_(m_temp.fun);   // the target of the tran.
        7:  366:            QS_END_PRE_()
        7:  367:            QS_MEM_APP();
        7:  368:            QS_CRIT_EXIT();
        -:  369:
        7:  370:            ip = 0;
        7:  371:            path[0] = m_temp.fun;
        -:  372:
        -:  373:            // find superstate
        7:  374:            static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        -:  375:
       11:  376:            while ((m_temp.fun != t) && (ip < (MAX_NEST_DEPTH_ - 1))) {
        4:  377:                ++ip;
        4:  378:                path[ip] = m_temp.fun;
        -:  379:                // find superstate
        4:  380:                static_cast<void>(
        4:  381:                    QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        -:  382:            }
        7:  383:            QF_CRIT_ENTRY();
        -:  384:            // The initial transition source state must be reached.
        -:  385:            // Too many state nesting levels or "malformed" HSM.
       7*:  386:            Q_ASSERT_INCRIT(330, m_temp.fun == t);
        7:  387:            QF_CRIT_EXIT();
        -:  388:
        7:  389:            m_temp.fun = path[0];
        -:  390:
        -:  391:            // retrace the entry path in reverse (correct) order...
       11:  392:            do {
        -:  393:                // enter path[ip]
       11:  394:                if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  395:                    == Q_RET_HANDLED)
        -:  396:                {
       11:  397:                    QS_STATE_ENTRY_(path[ip], qsId);
        -:  398:                }
       11:  399:                --ip;
       11:  400:            } while (ip >= 0);
        -:  401:
        7:  402:            t = path[0]; // current state becomes the new source
        -:  403:        }
        -:  404:
       14:  405:        QS_CRIT_ENTRY();
       14:  406:        QS_MEM_SYS();
       14:  407:        QS_BEGIN_PRE_(QS_QEP_TRAN, qsId)
       14:  408:            QS_TIME_PRE_();      // time stamp
       14:  409:            QS_SIG_PRE_(e->sig); // the signal of the event
       14:  410:            QS_OBJ_PRE_(this);   // this state machine object
       14:  411:            QS_FUN_PRE_(s);      // the source of the tran.
       14:  412:            QS_FUN_PRE_(t);      // the new active state
       14:  413:        QS_END_PRE_()
       14:  414:        QS_MEM_APP();
       14:  415:        QS_CRIT_EXIT();
        -:  416:    }
        -:  417:
        -:  418:    #ifdef Q_SPY
        4:  419:    else if (r == Q_RET_HANDLED) {
        2:  420:        QS_CRIT_ENTRY();
        2:  421:        QS_MEM_SYS();
        2:  422:        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qsId)
        2:  423:            QS_TIME_PRE_();      // time stamp
        2:  424:            QS_SIG_PRE_(e->sig); // the signal of the event
        2:  425:            QS_OBJ_PRE_(this);   // this state machine object
        2:  426:            QS_FUN_PRE_(s);      // the source state
        2:  427:        QS_END_PRE_()
        2:  428:        QS_MEM_APP();
        2:  429:        QS_CRIT_EXIT();
        -:  430:    }
        -:  431:    else {
        2:  432:        QS_CRIT_ENTRY();
        2:  433:        QS_MEM_SYS();
        2:  434:        QS_BEGIN_PRE_(QS_QEP_IGNORED, qsId)
        2:  435:            QS_TIME_PRE_();      // time stamp
        2:  436:            QS_SIG_PRE_(e->sig); // the signal of the event
        2:  437:            QS_OBJ_PRE_(this);   // this state machine object
        2:  438:            QS_FUN_PRE_(m_state.fun); // the current state
        2:  439:        QS_END_PRE_()
        2:  440:        QS_MEM_APP();
        2:  441:        QS_CRIT_EXIT();
        -:  442:    }
        -:  443:    #endif // Q_SPY
        -:  444:
       18:  445:    m_state.fun = t; // change the current active state
        -:  446:    #ifndef Q_UNSAFE
       18:  447:    m_temp.uint = ~m_state.uint;
        -:  448:    #endif
       18:  449:}
        -:  450:
        -:  451://${QEP::QHsm::isIn} .........................................................
        5:  452:bool QHsm::isIn(QStateHandler const state) noexcept {
        -:  453:    QF_CRIT_STAT
        5:  454:    QF_CRIT_ENTRY();
       5*:  455:    Q_REQUIRE_INCRIT(602, m_state.uint
        -:  456:                      == static_cast<std::uintptr_t>(~m_temp.uint));
        5:  457:    QF_CRIT_EXIT();
        -:  458:
        5:  459:    bool inState = false; // assume that this HSM is not in 'state'
        -:  460:
        -:  461:    // scan the state hierarchy bottom-up
        5:  462:    QStateHandler s = m_state.fun;
        5:  463:    std::int_fast8_t limit = MAX_NEST_DEPTH_ + 1; // loop hard limit
        5:  464:    QState r = Q_RET_SUPER;
       13:  465:    for (; (r != Q_RET_IGNORED) && (limit > 0); --limit) {
       12:  466:        if (s == state) { // do the states match?
        -:  467:            inState = true;  // 'true' means that match found
        -:  468:            break; // break out of the for-loop
        -:  469:        }
        -:  470:        else {
        8:  471:            r = QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG);
        8:  472:            s = m_temp.fun;
        -:  473:        }
        -:  474:    }
        -:  475:
        5:  476:    QF_CRIT_ENTRY();
       5*:  477:    Q_ENSURE_INCRIT(690, limit > 0);
        5:  478:    QF_CRIT_EXIT();
        -:  479:
        -:  480:    #ifndef Q_UNSAFE
        5:  481:    m_temp.uint = ~m_state.uint;
        -:  482:    #endif
        -:  483:
        5:  484:    return inState; // return the status
        -:  485:}
        -:  486:
        -:  487://${QEP::QHsm::childState} ...................................................
        1:  488:QStateHandler QHsm::childState(QStateHandler const parent) noexcept {
        1:  489:    QStateHandler child = m_state.fun; // start with the current state
        1:  490:    bool isFound = false; // start with the child not found
        -:  491:
        -:  492:    // establish stable state configuration
        1:  493:    m_temp.fun = child;
        4:  494:    QState r;
        4:  495:    do {
        -:  496:        // is this the parent of the current child?
        4:  497:        if (m_temp.fun == parent) {
        -:  498:            isFound = true; // child is found
        -:  499:            r = Q_RET_IGNORED; // break out of the loop
        -:  500:        }
        -:  501:        else {
        3:  502:            child = m_temp.fun;
        3:  503:            r = QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG);
        -:  504:        }
        4:  505:    } while (r != Q_RET_IGNORED); // QHsm::top() state not reached
        -:  506:
        -:  507:    #ifndef Q_UNSAFE
        1:  508:    m_temp.uint = ~m_state.uint;
        -:  509:    #endif
        -:  510:
        -:  511:    QF_CRIT_STAT
        1:  512:    QF_CRIT_ENTRY();
       1*:  513:    Q_ASSERT_INCRIT(890, isFound);
        1:  514:    QF_CRIT_EXIT();
        -:  515:
        1:  516:    return child; // return the child
        -:  517:}
        -:  518:
        -:  519://${QEP::QHsm::hsm_tran} .....................................................
       14:  520:std::int_fast8_t QHsm::hsm_tran(
        -:  521:    QStateHandler (&path)[MAX_NEST_DEPTH_],
        -:  522:    std::uint_fast8_t const qsId)
        -:  523:{
        -:  524:    #ifndef Q_SPY
        -:  525:    Q_UNUSED_PAR(qsId);
        -:  526:    #endif
        -:  527:
       14:  528:    std::int_fast8_t ip = -1; // tran. entry path index
       14:  529:    QStateHandler t = path[0];
       14:  530:    QStateHandler const s = path[2];
        -:  531:    QF_CRIT_STAT
        -:  532:
        -:  533:    // (a) check source==target (tran. to self)...
       14:  534:    if (s == t) {
        -:  535:        // exit source s
        1:  536:        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
        1:  537:            QS_STATE_EXIT_(s, qsId);
        -:  538:        }
        -:  539:        ip = 0; // enter the target
        -:  540:    }
        -:  541:    else {
        -:  542:        // find superstate of target
       13:  543:        static_cast<void>(QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
        -:  544:
       13:  545:        t = m_temp.fun;
        -:  546:
        -:  547:        // (b) check source==target->super...
       13:  548:        if (s == t) {
        -:  549:            ip = 0; // enter the target
        -:  550:        }
        -:  551:        else {
        -:  552:            // find superstate of src
       11:  553:            static_cast<void>(QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG));
        -:  554:
        -:  555:            // (c) check source->super==target->super...
       11:  556:            if (m_temp.fun == t) {
        -:  557:                // exit source s
        4:  558:                if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
        4:  559:                    QS_STATE_EXIT_(s, qsId);
        -:  560:                }
        -:  561:                ip = 0; // enter the target
        -:  562:            }
        -:  563:            else {
        -:  564:                // (d) check source->super==target...
        7:  565:                if (m_temp.fun == path[0]) {
        -:  566:                    // exit source s
        2:  567:                    if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
        2:  568:                        QS_STATE_EXIT_(s, qsId);
        -:  569:                    }
        -:  570:                }
        -:  571:                else {
        -:  572:                    // (e) check rest of source==target->super->super..
        -:  573:                    // and store the entry path along the way
        5:  574:                    std::int_fast8_t iq = 0; // indicate that LCA was found
        5:  575:                    ip = 1; // enter target and its superstate
        5:  576:                    path[1] = t;      // save the superstate of target
        5:  577:                    t = m_temp.fun;   // save source->super
        -:  578:
        -:  579:                    // find target->super->super...
        5:  580:                    QState r = QHSM_RESERVED_EVT_(path[1], Q_EMPTY_SIG);
       14:  581:                    while ((r == Q_RET_SUPER)
       14:  582:                           && (ip < (MAX_NEST_DEPTH_ - 1)))
        -:  583:                    {
        9:  584:                        ++ip;
        9:  585:                        path[ip] = m_temp.fun; // store the entry path
        9:  586:                        if (m_temp.fun == s) { // is it the source?
        -:  587:                            iq = 1; // indicate that the LCA found
        -:  588:                            --ip; // do not enter the source
        -:  589:                            r = Q_RET_HANDLED; // terminate the loop
        -:  590:                        }
        -:  591:                        else { // it is not the source, keep going up
        9:  592:                            r = QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG);
        -:  593:                        }
        -:  594:                    }
        5:  595:                    QF_CRIT_ENTRY();
        -:  596:                    // Tran. source must be found within the nesting depth
        -:  597:                    // Too many state nesting levels or "malformed" HSM.
       5*:  598:                    Q_ASSERT_INCRIT(510, r != Q_RET_SUPER);
        5:  599:                    QF_CRIT_EXIT();
        -:  600:
        -:  601:                    // the LCA not found yet?
        5:  602:                    if (iq == 0) {
        -:  603:                        // exit source s
        5:  604:                        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG)
        -:  605:                            == Q_RET_HANDLED)
        -:  606:                        {
        5:  607:                            QS_STATE_EXIT_(s, qsId);
        -:  608:                        }
        -:  609:
        -:  610:                        // (f) check the rest of source->super
        -:  611:                        //                  == target->super->super...
        5:  612:                        iq = ip;
        5:  613:                        r = Q_RET_IGNORED; // indicate that the LCA NOT found
       15:  614:                        do {
       15:  615:                            if (t == path[iq]) { // is this the LCA?
        2:  616:                                r = Q_RET_HANDLED; // indicate the LCA found
        2:  617:                                ip = iq - 1; // do not enter the LCA
        2:  618:                                iq = -1; // cause termination of the loop
        -:  619:                            }
        -:  620:                            else {
       13:  621:                                --iq; // try lower superstate of target
        -:  622:                            }
       15:  623:                        } while (iq >= 0);
        -:  624:
        -:  625:                        // the LCA not found yet?
        5:  626:                        if (r != Q_RET_HANDLED) {
        -:  627:                            // (g) check each source->super->...
        -:  628:                            // for each target->super...
        -:  629:                            r = Q_RET_IGNORED; // keep looping
        -:  630:                            std::int_fast8_t limit = MAX_NEST_DEPTH_;
        4:  631:                            do {
        -:  632:                                // exit from t
        4:  633:                                if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG)
        -:  634:                                    == Q_RET_HANDLED)
        -:  635:                                {
        4:  636:                                    QS_STATE_EXIT_(t, qsId);
        -:  637:                                    // find superstate of t
        4:  638:                                    static_cast<void>(
        4:  639:                                        QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
        -:  640:                                }
        4:  641:                                t = m_temp.fun; // set to super of t
        4:  642:                                iq = ip;
        8:  643:                                do {
        -:  644:                                    // is this the LCA?
        8:  645:                                    if (t == path[iq]) {
        3:  646:                                        ip = iq - 1; // do not enter the LCA
        3:  647:                                        iq = -1;     // break out of inner loop
        3:  648:                                        r = Q_RET_HANDLED; // break outer loop
        -:  649:                                    }
        -:  650:                                    else {
        5:  651:                                        --iq;
        -:  652:                                    }
        8:  653:                                } while (iq >= 0);
        -:  654:
        4:  655:                                --limit;
        4:  656:                            } while ((r != Q_RET_HANDLED) && (limit > 0));
        3:  657:                            QF_CRIT_ENTRY();
       3*:  658:                            Q_ASSERT_INCRIT(530, limit > 0);
        3:  659:                            QF_CRIT_EXIT();
        -:  660:                        }
        -:  661:                    }
        -:  662:                }
        -:  663:            }
        -:  664:        }
        -:  665:    }
       14:  666:    QF_CRIT_ENTRY();
      14*:  667:    Q_ENSURE_INCRIT(590, ip < MAX_NEST_DEPTH_);
       14:  668:    QF_CRIT_EXIT();
       14:  669:    return ip;
        -:  670:}
        -:  671:
        -:  672:} // namespace QP
        -:  673://$enddef${QEP::QHsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
