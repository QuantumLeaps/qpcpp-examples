        -:    0:Source:../../../../src/qf/qep_msm.cpp
        -:    0:Graph:build/qep_msm.gcno
        -:    0:Data:build/qep_msm.gcda
        -:    0:Runs:6
        -:    1://$file${src::qf::qep_msm.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:    2://
        -:    3:// Model: qpcpp.qm
        -:    4:// File:  ${src::qf::qep_msm.cpp}
        -:    5://
        -:    6:// This code has been generated by QM 6.1.1 <www.state-machine.com/qm>.
        -:    7:// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
        -:    8://
        -:    9:// This code is covered by the following QP license:
        -:   10:// License #    : LicenseRef-QL-dual
        -:   11:// Issued to    : Any user of the QP/C++ real-time embedded framework
        -:   12:// Framework(s) : qpcpp
        -:   13:// Support ends : 2024-12-31
        -:   14:// License scope:
        -:   15://
        -:   16:// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
        -:   17://
        -:   18://                    Q u a n t u m  L e a P s
        -:   19://                    ------------------------
        -:   20://                    Modern Embedded Software
        -:   21://
        -:   22:// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
        -:   23://
        -:   24:// This software is dual-licensed under the terms of the open source GNU
        -:   25:// General Public License version 3 (or any later version), or alternatively,
        -:   26:// under the terms of one of the closed source Quantum Leaps commercial
        -:   27:// licenses.
        -:   28://
        -:   29:// The terms of the open source GNU General Public License version 3
        -:   30:// can be found at: <www.gnu.org/licenses/gpl-3.0>
        -:   31://
        -:   32:// The terms of the closed source Quantum Leaps commercial licenses
        -:   33:// can be found at: <www.state-machine.com/licensing>
        -:   34://
        -:   35:// Redistributions in source code must retain this top-level comment block.
        -:   36:// Plagiarizing this software to sidestep the license obligations is illegal.
        -:   37://
        -:   38:// Contact information:
        -:   39:// <www.state-machine.com/licensing>
        -:   40:// <info@state-machine.com>
        -:   41://
        -:   42://$endhead${src::qf::qep_msm.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   43:#define QP_IMPL             // this is QP implementation
        -:   44:#include "qp_port.hpp"      // QP port
        -:   45:#include "qp_pkg.hpp"       // QP package-scope interface
        -:   46:#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
        -:   47:#ifdef Q_SPY                // QS software tracing enabled?
        -:   48:    #include "qs_port.hpp"  // QS port
        -:   49:    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
        -:   50:#else
        -:   51:    #include "qs_dummy.hpp" // disable the QS software tracing
        -:   52:#endif // Q_SPY
        -:   53:
        -:   54://============================================================================
        -:   55://! @cond INTERNAL
        -:   56:
        -:   57:// unnamed namespace for local definitions with internal linkage
        -:   58:namespace {
        -:   59:
        -:   60:Q_DEFINE_THIS_MODULE("qep_msm")
        -:   61:
        -:   62:// maximum depth of state nesting in a QMsm (including the top level)
        -:   63:static constexpr std::int_fast8_t MAX_NEST_DEPTH_ {6};
        -:   64:
        -:   65:// maximum length of transition-action array
        -:   66:static constexpr std::int_fast8_t MAX_TRAN_LENGTH_ {3*MAX_NEST_DEPTH_};
        -:   67:
        -:   68:// maximum depth of entry levels in a MSM for tran. to history.
        -:   69:static constexpr std::int_fast8_t MAX_ENTRY_DEPTH_ {4};
        -:   70:
        -:   71:// top-state object for QMsm-style state machines
        -:   72:QP::QMState const l_msm_top_s = {
        -:   73:    nullptr,
        -:   74:    nullptr,
        -:   75:    nullptr,
        -:   76:    nullptr,
        -:   77:    nullptr
        -:   78:};
        -:   79:
        -:   80:} // unnamed namespace
        -:   81:
        -:   82://! @endcond
        -:   83://============================================================================
        -:   84:
        -:   85://$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   86:// Check for the minimum required QP version
        -:   87:#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
        -:   88:#error qpcpp version 7.3.0 or higher required
        -:   89:#endif
        -:   90://$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   91:
        -:   92://$define${QEP::QMsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   93:namespace QP {
        -:   94:
        -:   95://${QEP::QMsm} ...............................................................
        -:   96:
        -:   97://${QEP::QMsm::QMsm} .........................................................
        6:   98:QMsm::QMsm(QStateHandler const initial) noexcept
        6:   99:  : QAsm()
        -:  100:{
        6:  101:    m_state.obj = &l_msm_top_s; // the current state (top)
        6:  102:    m_temp.fun  = initial;      // the initial tran. handler
        6:  103:}
        -:  104:
        -:  105://${QEP::QMsm::init} .........................................................
        6:  106:void QMsm::init(
        -:  107:    void const * const e,
        -:  108:    std::uint_fast8_t const qsId)
        -:  109:{
        -:  110:    #ifndef Q_SPY
        -:  111:    Q_UNUSED_PAR(qsId);
        -:  112:    #endif
        -:  113:
        -:  114:    QF_CRIT_STAT
        6:  115:    QF_CRIT_ENTRY();
       6*:  116:    Q_REQUIRE_INCRIT(200, (m_temp.fun != nullptr)
        -:  117:                      && (m_state.obj == &l_msm_top_s));
        6:  118:    QF_CRIT_EXIT();
        -:  119:
        -:  120:    // execute the top-most initial tran.
        6:  121:    QState r = (*m_temp.fun)(this, Q_EVT_CAST(QEvt));
        -:  122:
        6:  123:    QF_CRIT_ENTRY();
        -:  124:    // the top-most initial tran. must be taken
       6*:  125:    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN_INIT);
        -:  126:
        6:  127:    QS_MEM_SYS();
        6:  128:    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  129:        QS_OBJ_PRE_(this);  // this state machine object
        3:  130:        QS_FUN_PRE_(m_state.obj->stateHandler);          // source state
        3:  131:        QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target state
        3:  132:    QS_END_PRE_()
        6:  133:    QS_MEM_APP();
        -:  134:
        6:  135:    QF_CRIT_EXIT();
        -:  136:
        -:  137:    // set state to the last tran. target
        6:  138:    m_state.obj = m_temp.tatbl->target;
        -:  139:
        -:  140:    // drill down into the state hierarchy with initial transitions...
        6:  141:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
       12:  142:    do {
        -:  143:        // execute the tran. table
       12:  144:        r = execTatbl_(m_temp.tatbl, qsId);
       12:  145:        --limit;
       12:  146:    } while ((r >= Q_RET_TRAN_INIT) && (limit > 0));
        -:  147:
        6:  148:    QF_CRIT_ENTRY();
       6*:  149:    Q_ENSURE_INCRIT(290, limit > 0);
        -:  150:
        6:  151:    QS_MEM_SYS();
        6:  152:    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qsId)
        3:  153:        QS_TIME_PRE_();    // time stamp
        3:  154:        QS_OBJ_PRE_(this); // this state machine object
        3:  155:        QS_FUN_PRE_(m_state.obj->stateHandler); // the new current state
        3:  156:    QS_END_PRE_()
        6:  157:    QS_MEM_APP();
        -:  158:
        6:  159:    QF_CRIT_EXIT();
        -:  160:
        -:  161:    #ifndef Q_UNSAFE
        6:  162:    m_temp.uint = ~m_state.uint;
        -:  163:    #endif
        6:  164:}
        -:  165:
        -:  166://${QEP::QMsm::dispatch} .....................................................
       35:  167:void QMsm::dispatch(
        -:  168:    QEvt const * const e,
        -:  169:    std::uint_fast8_t const qsId)
        -:  170:{
        -:  171:    #ifndef Q_SPY
        -:  172:    Q_UNUSED_PAR(qsId);
        -:  173:    #endif
        -:  174:
       35:  175:    QMState const *s = m_state.obj; // store the current state
       35:  176:    QMState const *t = s;
        -:  177:
        -:  178:    QF_CRIT_STAT
       35:  179:    QF_CRIT_ENTRY();
      35*:  180:    Q_REQUIRE_INCRIT(300, (s != nullptr)
        -:  181:        && (m_state.uint == static_cast<std::uintptr_t>(~m_temp.uint)));
      35*:  182:    Q_REQUIRE_INCRIT(302, QEvt::verify_(e));
        -:  183:
       35:  184:    QS_MEM_SYS();
       35:  185:    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qsId)
       18:  186:        QS_TIME_PRE_();               // time stamp
       18:  187:        QS_SIG_PRE_(e->sig);          // the signal of the event
       18:  188:        QS_OBJ_PRE_(this);            // this state machine object
       18:  189:        QS_FUN_PRE_(s->stateHandler); // the current state handler
       18:  190:    QS_END_PRE_()
       35:  191:    QS_MEM_APP();
        -:  192:
       35:  193:    QF_CRIT_EXIT();
        -:  194:
        -:  195:    // scan the state hierarchy up to the top state...
       35:  196:    QState r;
       35:  197:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
       87:  198:    do {
       87:  199:        r = (*t->stateHandler)(this, e); // call state handler function
        -:  200:
        -:  201:        // event handled? (the most frequent case)
       87:  202:        if (r >= Q_RET_HANDLED) {
        -:  203:            break; // done scanning the state hierarchy
        -:  204:        }
        -:  205:        // event unhandled and passed to the superstate?
       55:  206:        else if (r == Q_RET_SUPER) {
       44:  207:            t = t->superstate; // advance to the superstate
        -:  208:        }
        -:  209:        // event unhandled and passed to a submachine superstate?
       11:  210:        else if (r == Q_RET_SUPER_SUB) {
        9:  211:            t = m_temp.obj; // current host state of the submachie
        -:  212:        }
        -:  213:        else { // event unhandled due to a guard?
        2:  214:            QF_CRIT_ENTRY();
        -:  215:            // event must be unhandled due to a guard evaluating to 'false'
       2*:  216:            Q_ASSERT_INCRIT(310, r == Q_RET_UNHANDLED);
        -:  217:
        2:  218:            QS_MEM_SYS();
        2:  219:            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qsId)
        1:  220:                QS_SIG_PRE_(e->sig);  // the signal of the event
        1:  221:                QS_OBJ_PRE_(this);    // this state machine object
        1:  222:                QS_FUN_PRE_(t->stateHandler); // the current state
        1:  223:            QS_END_PRE_()
        2:  224:            QS_MEM_APP();
        -:  225:
        2:  226:            QF_CRIT_EXIT();
        -:  227:
        2:  228:            t = t->superstate; // advance to the superstate
        -:  229:        }
       55:  230:        --limit;
       55:  231:    } while ((t != nullptr) && (limit > 0));
       35:  232:    QF_CRIT_ENTRY();
      35*:  233:    Q_ASSERT_INCRIT(310, limit > 0);
       35:  234:    QF_CRIT_EXIT();
        -:  235:
       35:  236:    if (r >= Q_RET_TRAN) { // any kind of tran. taken?
        -:  237:    #ifdef Q_SPY
       28:  238:        QMState const * const ts = t; // tran. source for QS tracing
        -:  239:
       28:  240:        QF_CRIT_ENTRY();
        -:  241:        // the tran. source state must not be nullptr
      28*:  242:        Q_ASSERT_INCRIT(320, ts != nullptr);
       28:  243:        QF_CRIT_EXIT();
        -:  244:    #endif // Q_SPY
        -:  245:
       28:  246:        limit = MAX_NEST_DEPTH_; // loop hard limit
       50:  247:        do {
        -:  248:            // save the tran-action table before it gets clobbered
       50:  249:            QMTranActTable const * const tatbl = m_temp.tatbl;
       50:  250:            QAsmAttr tmp; // temporary to save intermediate values
        -:  251:
        -:  252:            // was TRAN, TRAN_INIT, or TRAN_EP taken?
       50:  253:            if (r <= Q_RET_TRAN_EP) {
       38:  254:                m_temp.obj = nullptr; // clear
       38:  255:                exitToTranSource_(s, t, qsId);
       38:  256:                r = execTatbl_(tatbl, qsId);
       38:  257:                s = m_state.obj;
        -:  258:            }
        -:  259:            // was a tran. segment to history taken?
       12:  260:            else if (r == Q_RET_TRAN_HIST) {
        6:  261:                tmp.obj = m_state.obj; // save history
        6:  262:                m_state.obj = s; // restore the original state
        6:  263:                exitToTranSource_(s, t, qsId);
        6:  264:                static_cast<void>(execTatbl_(tatbl, qsId));
        6:  265:                r = enterHistory_(tmp.obj, qsId);
        6:  266:                s = m_state.obj;
        -:  267:            }
        -:  268:            else {
        6:  269:                QF_CRIT_ENTRY();
        -:  270:                // must be tran. to exit point
       6*:  271:                Q_ASSERT_INCRIT(340, r == Q_RET_TRAN_XP);
        6:  272:                QF_CRIT_EXIT();
        -:  273:
        6:  274:                tmp.act = m_state.act; // save XP action
        6:  275:                m_state.obj = s; // restore the original state
        6:  276:                r = (*tmp.act)(this); // execute the XP action
        6:  277:                if (r == Q_RET_TRAN) { // XP -> TRAN ?
        -:  278:    #ifdef Q_SPY
        2:  279:                    tmp.tatbl = m_temp.tatbl; // save m_temp
        -:  280:    #endif // Q_SPY
        2:  281:                    exitToTranSource_(s, t, qsId);
        -:  282:                    // take the tran-to-XP segment inside submachine
        2:  283:                    static_cast<void>(execTatbl_(tatbl, qsId));
        2:  284:                    s = m_state.obj;
        -:  285:    #ifdef Q_SPY
        2:  286:                    m_temp.tatbl = tmp.tatbl; // restore m_temp
        -:  287:    #endif // Q_SPY
        -:  288:                }
        4:  289:                else if (r == Q_RET_TRAN_HIST) { // XP -> HIST ?
        4:  290:                    tmp.obj = m_state.obj; // save the history
        4:  291:                    m_state.obj = s; // restore the original state
        -:  292:    #ifdef Q_SPY
        4:  293:                    s = m_temp.obj; // save m_temp
        -:  294:    #endif // Q_SPY
        4:  295:                    exitToTranSource_(m_state.obj, t, qsId);
        -:  296:                    // take the tran-to-XP segment inside submachine
        4:  297:                    static_cast<void>(execTatbl_(tatbl, qsId));
        -:  298:    #ifdef Q_SPY
        4:  299:                    m_temp.obj = s; // restore m_temp
        -:  300:    #endif // Q_SPY
        4:  301:                    s = m_state.obj;
        4:  302:                    m_state.obj = tmp.obj; // restore the history
        -:  303:                }
        -:  304:                else {
    #####:  305:                    QF_CRIT_ENTRY();
        -:  306:                    // TRAN_XP must NOT be followed by any other tran type
    #####:  307:                    Q_ASSERT_INCRIT(330, r < Q_RET_TRAN);
    #####:  308:                    QF_CRIT_EXIT();
        -:  309:                }
        -:  310:            }
        -:  311:
       50:  312:            t = s; // set target to the current state
       50:  313:           --limit;
       50:  314:        } while ((r >= Q_RET_TRAN) && (limit > 0));
        -:  315:
       28:  316:        QF_CRIT_ENTRY();
      28*:  317:        Q_ASSERT_INCRIT(320, limit > 0);
        -:  318:
       28:  319:        QS_MEM_SYS();
       28:  320:        QS_BEGIN_PRE_(QS_QEP_TRAN, qsId)
       14:  321:            QS_TIME_PRE_();                 // time stamp
       14:  322:            QS_SIG_PRE_(e->sig);            // the signal of the event
       14:  323:            QS_OBJ_PRE_(this);              // this state machine object
       14:  324:            QS_FUN_PRE_(ts->stateHandler);  // the tran. source
       14:  325:            QS_FUN_PRE_(s->stateHandler);   // the new active state
       14:  326:        QS_END_PRE_()
       28:  327:        QS_MEM_APP();
        -:  328:
       28:  329:        QF_CRIT_EXIT();
        -:  330:    }
        -:  331:
        -:  332:    #ifdef Q_SPY
        -:  333:    // was the event handled?
        7:  334:    else if (r == Q_RET_HANDLED) {
        4:  335:        QF_CRIT_ENTRY();
        -:  336:        // internal tran. source can't be nullptr
       4*:  337:        Q_ASSERT_INCRIT(340, t != nullptr);
        -:  338:
        4:  339:        QS_MEM_SYS();
        4:  340:        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qsId)
        2:  341:            QS_TIME_PRE_();                 // time stamp
        2:  342:            QS_SIG_PRE_(e->sig);            // the signal of the event
        2:  343:            QS_OBJ_PRE_(this);              // this state machine object
        2:  344:            QS_FUN_PRE_(t->stateHandler);   // the source state
        2:  345:        QS_END_PRE_()
        4:  346:        QS_MEM_APP();
        -:  347:
        4:  348:        QF_CRIT_EXIT();
        -:  349:    }
        -:  350:    // event bubbled to the 'top' state?
        3:  351:    else if (t == nullptr) {
        3:  352:        QS_CRIT_ENTRY();
        3:  353:        QS_MEM_SYS();
        3:  354:        QS_BEGIN_PRE_(QS_QEP_IGNORED, qsId)
        2:  355:            QS_TIME_PRE_();                 // time stamp
        2:  356:            QS_SIG_PRE_(e->sig);            // the signal of the event
        2:  357:            QS_OBJ_PRE_(this);              // this state machine object
        2:  358:            QS_FUN_PRE_(s->stateHandler);   // the current state
        2:  359:        QS_END_PRE_()
        3:  360:        QS_MEM_APP();
        3:  361:        QS_CRIT_EXIT();
        -:  362:    }
        -:  363:    #endif // Q_SPY
        -:  364:    else {
        -:  365:        // empty
        -:  366:    }
        -:  367:
        -:  368:    #ifndef Q_UNSAFE
       35:  369:    m_temp.uint = ~m_state.uint;
        -:  370:    #endif
       35:  371:}
        -:  372:
        -:  373://${QEP::QMsm::isIn} .........................................................
        8:  374:bool QMsm::isIn(QStateHandler const state) noexcept {
        8:  375:    bool inState = false; // assume that this SM is not in 'state'
        -:  376:
        8:  377:    QMState const *s = m_state.obj;
        8:  378:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
       17:  379:    for (; (s != nullptr) && (limit > 0); --limit) {
       14:  380:        if (s->stateHandler == state) { // match found?
        -:  381:            inState = true;
        -:  382:            break;
        -:  383:        }
        -:  384:        else {
        9:  385:            s = s->superstate; // advance to the superstate
        -:  386:        }
        -:  387:    }
        -:  388:
        -:  389:    QF_CRIT_STAT
        8:  390:    QF_CRIT_ENTRY();
       8*:  391:    Q_ENSURE_INCRIT(490, limit > 0);
        8:  392:    QF_CRIT_EXIT();
        -:  393:
        8:  394:    return inState;
        -:  395:}
        -:  396:
        -:  397://${QEP::QMsm::isInState} ....................................................
    #####:  398:bool QMsm::isInState(QMState const * const stateObj) const noexcept {
    #####:  399:    bool inState = false; // assume that this SM is not in 'state'
        -:  400:
    #####:  401:    QMState const *s = m_state.obj;
    #####:  402:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
    #####:  403:    for (; (s != nullptr) && (limit > 0); --limit) {
    #####:  404:        if (s == stateObj) { // match found?
        -:  405:            inState = true;
        -:  406:            break;
        -:  407:        }
        -:  408:        else {
    #####:  409:            s = s->superstate; // advance to the superstate
        -:  410:        }
        -:  411:    }
        -:  412:
        -:  413:    QF_CRIT_STAT
    #####:  414:    QF_CRIT_ENTRY();
    #####:  415:    Q_ENSURE_INCRIT(590, limit > 0);
    #####:  416:    QF_CRIT_EXIT();
        -:  417:
    #####:  418:    return inState;
        -:  419:}
        -:  420:
        -:  421://${QEP::QMsm::childStateObj} ................................................
        2:  422:QMState const * QMsm::childStateObj(QMState const * const parent) const noexcept {
        2:  423:    QMState const *child = m_state.obj;
        2:  424:    bool isFound = false; // start with the child not found
        2:  425:    QMState const *s;
        -:  426:
        2:  427:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
        2:  428:    for (s = m_state.obj;
        8:  429:         (s != nullptr) && (limit > 0);
        6:  430:         s = s->superstate)
        -:  431:    {
        6:  432:        if (s == parent) {
        -:  433:            isFound = true; // child is found
        -:  434:            break;
        -:  435:        }
        -:  436:        else {
        6:  437:            child = s;
        -:  438:        }
        6:  439:        --limit;
        -:  440:    }
        -:  441:    QF_CRIT_STAT
        2:  442:    QF_CRIT_ENTRY();
       2*:  443:    Q_ASSERT_INCRIT(610, limit > 0);
        2:  444:    QF_CRIT_EXIT();
        -:  445:
        2:  446:    if (!isFound) { // still not found?
        2:  447:        limit = MAX_NEST_DEPTH_; // loop hard limit
        2:  448:        for (s = m_temp.obj;
        4:  449:             (s != nullptr) && (limit > 0);
        2:  450:             s = s->superstate)
        -:  451:        {
        4:  452:            if (s == parent) {
        -:  453:                isFound = true; // child is found
        -:  454:                break;
        -:  455:            }
        -:  456:            else {
        2:  457:                child = s;
        -:  458:            }
        2:  459:            --limit;
        -:  460:        }
        -:  461:    }
        -:  462:
        2:  463:    QF_CRIT_ENTRY();
       2*:  464:    Q_ENSURE_INCRIT(690, isFound && (limit > 0));
        2:  465:    QF_CRIT_EXIT();
        -:  466:
        2:  467:    return child; // return the child
        -:  468:}
        -:  469:
        -:  470://${QEP::QMsm::execTatbl_} ...................................................
       62:  471:QState QMsm::execTatbl_(
        -:  472:    QMTranActTable const * const tatbl,
        -:  473:    std::uint_fast8_t const qsId)
        -:  474:{
        -:  475:    #ifndef Q_SPY
        -:  476:    Q_UNUSED_PAR(qsId);
        -:  477:    #endif
        -:  478:
        -:  479:    QF_CRIT_STAT
       62:  480:    QF_CRIT_ENTRY();
        -:  481:    // precondition:
        -:  482:    // - the tran-action table pointer must not be NULL
      62*:  483:    Q_REQUIRE_INCRIT(700, tatbl != nullptr);
       62:  484:    QF_CRIT_EXIT();
        -:  485:
       62:  486:    QState r = Q_RET_NULL;
       62:  487:    std::int_fast8_t limit = MAX_TRAN_LENGTH_; // loop hard limit
       62:  488:    QActionHandler const *a = &tatbl->act[0];
      182:  489:    for (; (*a != nullptr) && (limit > 0); ++a) {
      120:  490:        r = (*(*a))(this); // call the action through the 'a' pointer
        -:  491:    #ifdef Q_SPY
      120:  492:        QS_CRIT_ENTRY();
      120:  493:        QS_MEM_SYS();
      120:  494:        if (r == Q_RET_ENTRY) {
       70:  495:            QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qsId)
       35:  496:                QS_OBJ_PRE_(this); // this state machine object
       35:  497:                QS_FUN_PRE_(m_temp.obj->stateHandler); // entered state
       35:  498:            QS_END_PRE_()
        -:  499:        }
       50:  500:        else if (r == Q_RET_EXIT) {
       30:  501:            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qsId)
       15:  502:                QS_OBJ_PRE_(this); // this state machine object
       15:  503:                QS_FUN_PRE_(m_temp.obj->stateHandler); // exited state
       15:  504:            QS_END_PRE_()
        -:  505:        }
       20:  506:        else if (r == Q_RET_TRAN_INIT) {
       18:  507:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        9:  508:                QS_OBJ_PRE_(this); // this state machine object
        9:  509:                QS_FUN_PRE_(tatbl->target->stateHandler);        // source
        9:  510:                QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
        9:  511:            QS_END_PRE_()
        -:  512:        }
        2:  513:        else if (r == Q_RET_TRAN_EP) {
        2:  514:            QS_BEGIN_PRE_(QS_QEP_TRAN_EP, qsId)
        1:  515:                QS_OBJ_PRE_(this); // this state machine object
        1:  516:                QS_FUN_PRE_(tatbl->target->stateHandler);        // source
        1:  517:                QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
        1:  518:            QS_END_PRE_()
        -:  519:        }
    #####:  520:        else if (r == Q_RET_TRAN_XP) {
    #####:  521:            QS_BEGIN_PRE_(QS_QEP_TRAN_XP, qsId)
    #####:  522:                QS_OBJ_PRE_(this); // this state machine object
    #####:  523:                QS_FUN_PRE_(tatbl->target->stateHandler);        // source
    #####:  524:                QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
    #####:  525:            QS_END_PRE_()
        -:  526:        }
        -:  527:        else {
        -:  528:            // empty
        -:  529:        }
      120:  530:        QS_MEM_APP();
      120:  531:        QS_CRIT_EXIT();
        -:  532:    #endif // Q_SPY
      120:  533:        --limit;
        -:  534:    }
       62:  535:    QF_CRIT_ENTRY();
      62*:  536:    Q_ENSURE_INCRIT(790, *a == nullptr);
       62:  537:    QF_CRIT_EXIT();
        -:  538:
       62:  539:    m_state.obj = (r >= Q_RET_TRAN)
       20:  540:        ? m_temp.tatbl->target
        -:  541:        : tatbl->target;
       62:  542:    return r;
        -:  543:}
        -:  544:
        -:  545://${QEP::QMsm::exitToTranSource_} ............................................
       50:  546:void QMsm::exitToTranSource_(
        -:  547:    QMState const * const cs,
        -:  548:    QMState const * const ts,
        -:  549:    std::uint_fast8_t const qsId)
        -:  550:{
        -:  551:    #ifndef Q_SPY
        -:  552:    Q_UNUSED_PAR(qsId);
        -:  553:    #endif
        -:  554:
        -:  555:    QF_CRIT_STAT
        -:  556:
        -:  557:    // exit states from the current state to the tran. source state
       50:  558:    QMState const *s = cs;
       50:  559:    std::int_fast8_t limit = MAX_NEST_DEPTH_; // loop hard limit
       78:  560:    for (; (s != ts) && (limit > 0); --limit) {
        -:  561:        // exit action provided in state 's'?
       28:  562:        if (s->exitAction != nullptr) {
        -:  563:            // execute the exit action
       26:  564:            static_cast<void>((*s->exitAction)(this));
        -:  565:
       26:  566:            QS_CRIT_ENTRY();
       26:  567:            QS_MEM_SYS();
       26:  568:            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qsId)
       13:  569:                QS_OBJ_PRE_(this);            // this state machine object
       13:  570:                QS_FUN_PRE_(s->stateHandler); // the exited state handler
       13:  571:            QS_END_PRE_()
       26:  572:            QS_MEM_APP();
       26:  573:            QS_CRIT_EXIT();
        -:  574:        }
        -:  575:
       28:  576:        s = s->superstate; // advance to the superstate
        -:  577:
       28:  578:        if (s == nullptr) { // reached the top of a submachine?
        4:  579:            s = m_temp.obj; // the superstate from QM_SM_EXIT()
        4:  580:            QF_CRIT_ENTRY();
       4*:  581:            Q_ASSERT_INCRIT(810, s != nullptr); // must be valid
        4:  582:            QF_CRIT_EXIT();
        -:  583:        }
        -:  584:    }
       50:  585:    QF_CRIT_ENTRY();
      50*:  586:    Q_ENSURE_INCRIT(890, limit > 0);
       50:  587:    QF_CRIT_EXIT();
       50:  588:}
        -:  589:
        -:  590://${QEP::QMsm::enterHistory_} ................................................
        6:  591:QState QMsm::enterHistory_(
        -:  592:    QMState const * const hist,
        -:  593:    std::uint_fast8_t const qsId)
        -:  594:{
        -:  595:    #ifndef Q_SPY
        -:  596:    Q_UNUSED_PAR(qsId);
        -:  597:    #endif
        -:  598:
        6:  599:    QMState const *s = hist;
        6:  600:    QMState const *ts = m_state.obj; // tran. source
        6:  601:    QMState const *epath[MAX_ENTRY_DEPTH_];
        -:  602:
        -:  603:    QF_CRIT_STAT
        -:  604:
        6:  605:    QS_CRIT_ENTRY();
        6:  606:    QS_MEM_SYS();
        6:  607:    QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qsId)
        3:  608:        QS_OBJ_PRE_(this);               // this state machine object
        3:  609:        QS_FUN_PRE_(ts->stateHandler);   // source state handler
        3:  610:        QS_FUN_PRE_(hist->stateHandler); // target state handler
        3:  611:    QS_END_PRE_()
        6:  612:    QS_MEM_APP();
        6:  613:    QS_CRIT_EXIT();
        -:  614:
        6:  615:    std::int_fast8_t i = 0; // tran. entry path index
       16:  616:    while ((s != ts) && (i < MAX_ENTRY_DEPTH_)) {
       10:  617:        if (s->entryAction != nullptr) {
       10:  618:            epath[i] = s;
       10:  619:            ++i;
        -:  620:        }
       10:  621:        s = s->superstate;
       10:  622:        if (s == nullptr) {
    #####:  623:            ts = s; // force exit from the for-loop
        -:  624:        }
        -:  625:    }
        6:  626:    QF_CRIT_ENTRY();
       6*:  627:    Q_ASSERT_INCRIT(910, s == ts);
        6:  628:    QF_CRIT_EXIT();
        -:  629:
        -:  630:    // retrace the entry path in reverse (desired) order...
       16:  631:    while (i > 0) {
       10:  632:        --i;
       10:  633:        (*epath[i]->entryAction)(this); // run entry action in epath[i]
        -:  634:
       10:  635:        QS_CRIT_ENTRY();
       10:  636:        QS_MEM_SYS();
       10:  637:        QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qsId)
        5:  638:            QS_OBJ_PRE_(this);
        5:  639:            QS_FUN_PRE_(epath[i]->stateHandler); // entered state handler
        5:  640:        QS_END_PRE_()
       10:  641:        QS_MEM_APP();
       10:  642:        QS_CRIT_EXIT();
        -:  643:    }
        -:  644:
        6:  645:    m_state.obj = hist; // set current state to the tran. target
        -:  646:
        -:  647:    // initial tran. present?
        6:  648:    QState r;
        6:  649:    if (hist->initAction != nullptr) {
        2:  650:        r = (*hist->initAction)(this); // execute the tran. action
        -:  651:    }
        -:  652:    else {
        -:  653:        r = Q_RET_NULL;
        -:  654:    }
        -:  655:
        6:  656:    return r;
        -:  657:}
        -:  658:
        -:  659://${QEP::QMsm::topQMState} ...................................................
    #####:  660:QMState const * QMsm::topQMState() const noexcept {
    #####:  661:    return &l_msm_top_s;
        -:  662:}
        -:  663:
        -:  664:} // namespace QP
        -:  665://$enddef${QEP::QMsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
