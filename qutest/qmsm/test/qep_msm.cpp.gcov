        -:    0:Source:../../../../src/qf/qep_msm.cpp
        -:    0:Graph:build/qep_msm.gcno
        -:    0:Data:build/qep_msm.gcda
        -:    0:Runs:6
        -:    1://$file${src::qf::qep_msm.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:    2://
        -:    3:// Model: qpcpp.qm
        -:    4:// File:  ${src::qf::qep_msm.cpp}
        -:    5://
        -:    6:// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
        -:    7:// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
        -:    8://
        -:    9:// This generated code is covered by the following QP license:
        -:   10:// License #    : LicenseRef-QL-dual
        -:   11:// Issued to    : General public
        -:   12:// Framework(s) : qpcpp
        -:   13:// Support ends : 2025-12-31
        -:   14://
        -:   15:// Copyright (C) 2005 Quantum Leaps, LLC. All rights reserved.
        -:   16://
        -:   17://                    Q u a n t u m  L e a P s
        -:   18://                    ------------------------
        -:   19://                    Modern Embedded Software
        -:   20://
        -:   21:// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
        -:   22://
        -:   23:// The QP/C++ software is dual-licensed under the terms of the open-source
        -:   24:// GNU General Public License (GPL) or under the terms of one of the closed-
        -:   25:// source Quantum Leaps commercial licenses.
        -:   26://
        -:   27:// Redistributions in source code must retain this top-level comment block.
        -:   28:// Plagiarizing this software to sidestep the license obligations is illegal.
        -:   29://
        -:   30:// NOTE:
        -:   31:// The GPL (see <www.gnu.org/licenses/gpl-3.0>) does NOT permit the
        -:   32:// incorporation of the QP/C++ software into proprietary programs. Please
        -:   33:// contact Quantum Leaps for commercial licensing options, which expressly
        -:   34:// supersede the GPL and are designed explicitly for licensees interested
        -:   35:// in using QP/C++ in closed-source proprietary applications.
        -:   36://
        -:   37:// Quantum Leaps contact information:
        -:   38:// <www.state-machine.com/licensing>
        -:   39:// <info@state-machine.com>
        -:   40://
        -:   41://$endhead${src::qf::qep_msm.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   42:#define QP_IMPL             // this is QP implementation
        -:   43:#include "qp_port.hpp"      // QP port
        -:   44:#include "qp_pkg.hpp"       // QP package-scope interface
        -:   45:#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
        -:   46:#ifdef Q_SPY                // QS software tracing enabled?
        -:   47:    #include "qs_port.hpp"  // QS port
        -:   48:    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
        -:   49:#else
        -:   50:    #include "qs_dummy.hpp" // disable the QS software tracing
        -:   51:#endif // Q_SPY
        -:   52:
        -:   53://============================================================================
        -:   54://! @cond INTERNAL
        -:   55:
        -:   56:// unnamed namespace for local definitions with internal linkage
        -:   57:namespace {
        -:   58:
        -:   59:Q_DEFINE_THIS_MODULE("qep_msm")
        -:   60:
        -:   61:// top-state object for QMsm-style state machines
        -:   62:QP::QMState const l_msm_top_s = {
        -:   63:    nullptr,
        -:   64:    nullptr,
        -:   65:    nullptr,
        -:   66:    nullptr,
        -:   67:    nullptr
        -:   68:};
        -:   69:
        -:   70:} // unnamed namespace
        -:   71:
        -:   72://! @endcond
        -:   73:
        -:   74:// maximum depth of state nesting in a QMsm (including the top level)
        -:   75:static constexpr std::int_fast8_t QMSM_MAX_NEST_DEPTH_ {8};
        -:   76:
        -:   77:// maximum length of transition-action array
        -:   78:static constexpr std::int_fast8_t QMSM_MAX_TRAN_LENGTH_ {2*QMSM_MAX_NEST_DEPTH_};
        -:   79:
        -:   80:// maximum depth of entry levels in a MSM for tran. to history.
        -:   81:static constexpr std::int_fast8_t QMSM_MAX_ENTRY_DEPTH_ {4};
        -:   82://============================================================================
        -:   83:
        -:   84://$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   85:// Check for the minimum required QP version
        -:   86:#if (QP_VERSION < 750U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
        -:   87:#error qpcpp version 7.5.0 or higher required
        -:   88:#endif
        -:   89://$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   90://$define${QEP::QMsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   91:namespace QP {
        -:   92:
        -:   93://${QEP::QMsm} ...............................................................
        -:   94:
        -:   95://${QEP::QMsm::QMsm} .........................................................
        6:   96:QMsm::QMsm(QStateHandler const initial) noexcept
        6:   97:  : QAsm()
        -:   98:{
        6:   99:    m_state.obj = &l_msm_top_s; // the current state (top)
        6:  100:    m_temp.fun  = initial;      // the initial tran. handler
        6:  101:}
        -:  102:
        -:  103://${QEP::QMsm::init} .........................................................
        6:  104:void QMsm::init(
        -:  105:    void const * const e,
        -:  106:    std::uint_fast8_t const qsId)
        -:  107:{
        -:  108:    #ifndef Q_SPY
        -:  109:    Q_UNUSED_PAR(qsId);
        -:  110:    #endif
        -:  111:
        -:  112:    QF_CRIT_STAT
        6:  113:    QF_CRIT_ENTRY();
       6*:  114:    Q_REQUIRE_INCRIT(200, (m_temp.fun != nullptr)
        -:  115:                      && (m_state.obj == &l_msm_top_s));
        6:  116:    QF_CRIT_EXIT();
        -:  117:
        -:  118:    // execute the top-most initial tran.
        6:  119:    QState r = (*m_temp.fun)(this, Q_EVT_CAST(QEvt));
        -:  120:
        6:  121:    QF_CRIT_ENTRY();
        -:  122:    // the top-most initial tran. must be taken
       6*:  123:    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN_INIT);
        -:  124:
        6:  125:    QS_MEM_SYS();
        6:  126:    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  127:        QS_OBJ_PRE_(this);  // this state machine object
        3:  128:        QS_FUN_PRE_(m_state.obj->stateHandler);          // source state
        3:  129:        QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target state
        3:  130:    QS_END_PRE_()
        6:  131:    QS_MEM_APP();
        -:  132:
        6:  133:    QF_CRIT_EXIT();
        -:  134:
        -:  135:    // set state to the last tran. target
        6:  136:    m_state.obj = m_temp.tatbl->target;
        -:  137:
        -:  138:    // drill down into the state hierarchy with initial transitions...
        6:  139:    std::int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       12:  140:    do {
        -:  141:        // execute the tran. table
       12:  142:        r = execTatbl_(m_temp.tatbl, qsId);
       12:  143:        --lbound;
       12:  144:    } while ((r >= Q_RET_TRAN_INIT) && (lbound > 0));
        -:  145:
        6:  146:    QF_CRIT_ENTRY();
       6*:  147:    Q_ENSURE_INCRIT(290, lbound > 0);
        -:  148:
        6:  149:    QS_MEM_SYS();
        6:  150:    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qsId)
        3:  151:        QS_TIME_PRE_();    // time stamp
        3:  152:        QS_OBJ_PRE_(this); // this state machine object
        3:  153:        QS_FUN_PRE_(m_state.obj->stateHandler); // the new current state
        3:  154:    QS_END_PRE_()
        6:  155:    QS_MEM_APP();
        -:  156:
        6:  157:    QF_CRIT_EXIT();
        -:  158:
        -:  159:    #ifndef Q_UNSAFE
        6:  160:    m_temp.uint = ~m_state.uint;
        -:  161:    #endif
        6:  162:}
        -:  163:
        -:  164://${QEP::QMsm::dispatch} .....................................................
       41:  165:void QMsm::dispatch(
        -:  166:    QEvt const * const e,
        -:  167:    std::uint_fast8_t const qsId)
        -:  168:{
        -:  169:    #ifndef Q_SPY
        -:  170:    Q_UNUSED_PAR(qsId);
        -:  171:    #endif
        -:  172:
       41:  173:    QMState const *s = m_state.obj; // store the current state
       41:  174:    QMState const *t = s;
        -:  175:
        -:  176:    QF_CRIT_STAT
       41:  177:    QF_CRIT_ENTRY();
      41*:  178:    Q_REQUIRE_INCRIT(300, QEvt::verify_(e));
      41*:  179:    Q_INVARIANT_INCRIT(302, (s != nullptr)
        -:  180:        && (m_state.uint == static_cast<std::uintptr_t>(~m_temp.uint)));
        -:  181:
       41:  182:    QS_MEM_SYS();
       41:  183:    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qsId)
       21:  184:        QS_TIME_PRE_();               // time stamp
       21:  185:        QS_SIG_PRE_(e->sig);          // the signal of the event
       21:  186:        QS_OBJ_PRE_(this);            // this state machine object
       21:  187:        QS_FUN_PRE_(s->stateHandler); // the current state handler
       21:  188:    QS_END_PRE_()
       41:  189:    QS_MEM_APP();
        -:  190:
       41:  191:    QF_CRIT_EXIT();
        -:  192:
        -:  193:    // scan the state hierarchy up to the top state...
       41:  194:    QState r;
       41:  195:    std::int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       90:  196:    do {
       90:  197:        r = (*t->stateHandler)(this, e); // call state handler function
        -:  198:
        -:  199:        // event handled? (the most frequent case)
       90:  200:        if (r >= Q_RET_HANDLED) {
        -:  201:            break; // done scanning the state hierarchy
        -:  202:        }
        -:  203:        // event unhandled and passed to the superstate?
       52:  204:        else if (r == Q_RET_SUPER) {
       48:  205:            t = t->superstate; // advance to the superstate
        -:  206:        }
        -:  207:        else { // event unhandled due to a guard
        4:  208:            QF_CRIT_ENTRY();
        -:  209:            // event must be unhandled due to a guard evaluating to 'false'
       4*:  210:            Q_ASSERT_INCRIT(310, r == Q_RET_UNHANDLED);
        -:  211:
        4:  212:            QS_MEM_SYS();
        4:  213:            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qsId)
        2:  214:                QS_SIG_PRE_(e->sig);  // the signal of the event
        2:  215:                QS_OBJ_PRE_(this);    // this state machine object
        2:  216:                QS_FUN_PRE_(t->stateHandler); // the current state
        2:  217:            QS_END_PRE_()
        4:  218:            QS_MEM_APP();
        -:  219:
        4:  220:            QF_CRIT_EXIT();
        -:  221:
        4:  222:            t = t->superstate; // advance to the superstate
        -:  223:        }
       52:  224:        --lbound;
       52:  225:    } while ((t != nullptr) && (lbound > 0));
       41:  226:    QF_CRIT_ENTRY();
      41*:  227:    Q_ENSURE_INCRIT(320, lbound > 0);
       41:  228:    QF_CRIT_EXIT();
        -:  229:
       41:  230:    if (r >= Q_RET_TRAN) { // any kind of tran. taken?
       34:  231:        QF_CRIT_ENTRY();
        -:  232:        // the tran. source state must not be nullptr
      34*:  233:        Q_ASSERT_INCRIT(330, t != nullptr);
       34:  234:        QF_CRIT_EXIT();
        -:  235:
        -:  236:    #ifdef Q_SPY
       34:  237:        QMState const * const ts = t; // for saving tran. table
        -:  238:    #endif // Q_SPY
       34:  239:        QMTranActTable const *tatbl;
        -:  240:
       34:  241:        if (r == Q_RET_TRAN_HIST) { // was it tran. to history?
        8:  242:            QMState const *hist = m_state.obj; // save history
        8:  243:            m_state.obj = s; // restore the original state
        -:  244:
        8:  245:            QS_CRIT_ENTRY();
        8:  246:            QS_MEM_SYS();
        8:  247:            QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qsId)
        4:  248:                QS_OBJ_PRE_(this); // this state machine object
        4:  249:                QS_FUN_PRE_(t->stateHandler);    // source state handler
        4:  250:                QS_FUN_PRE_(hist->stateHandler); // target state handler
        4:  251:            QS_END_PRE_()
        8:  252:            QS_MEM_APP();
        8:  253:            QS_CRIT_EXIT();
        -:  254:
        -:  255:            // save the tran-action table before it gets clobbered
        8:  256:            tatbl = m_temp.tatbl;
        8:  257:            exitToTranSource_(s, t, qsId);
        8:  258:            static_cast<void>(execTatbl_(tatbl, qsId));
        8:  259:            r = enterHistory_(hist, qsId);
        8:  260:            s = m_state.obj;
        8:  261:            t = s; // set target to the current state
        -:  262:        }
        -:  263:
        -:  264:        lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       76:  265:        while ((r >= Q_RET_TRAN) && (lbound > 0)) {
        -:  266:            // save the tran-action table before it gets clobbered
       42:  267:            tatbl = m_temp.tatbl;
       42:  268:            m_temp.obj = nullptr; // clear
       42:  269:            exitToTranSource_(s, t, qsId);
       42:  270:            r = execTatbl_(tatbl, qsId);
       42:  271:            s = m_state.obj;
       42:  272:            t = s; // set target to the current state
       42:  273:            --lbound;
        -:  274:        }
        -:  275:
       34:  276:        QF_CRIT_ENTRY();
      34*:  277:        Q_ENSURE_INCRIT(360, lbound > 0);
        -:  278:
       34:  279:        QS_MEM_SYS();
       34:  280:        QS_BEGIN_PRE_(QS_QEP_TRAN, qsId)
       17:  281:            QS_TIME_PRE_();                 // time stamp
       17:  282:            QS_SIG_PRE_(e->sig);            // the signal of the event
       17:  283:            QS_OBJ_PRE_(this);              // this state machine object
       17:  284:            QS_FUN_PRE_(ts->stateHandler);  // the tran. source
       17:  285:            QS_FUN_PRE_(s->stateHandler);   // the new active state
       17:  286:        QS_END_PRE_()
       34:  287:        QS_MEM_APP();
        -:  288:
       34:  289:        QF_CRIT_EXIT();
        -:  290:    }
        -:  291:
        -:  292:    #ifdef Q_SPY
        -:  293:    // was the event handled?
        7:  294:    else if (r == Q_RET_HANDLED) {
        4:  295:        QF_CRIT_ENTRY();
        -:  296:        // internal tran. source can't be nullptr
       4*:  297:        Q_ASSERT_INCRIT(380, t != nullptr);
        -:  298:
        4:  299:        QS_MEM_SYS();
        4:  300:        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qsId)
        2:  301:            QS_TIME_PRE_();                 // time stamp
        2:  302:            QS_SIG_PRE_(e->sig);            // the signal of the event
        2:  303:            QS_OBJ_PRE_(this);              // this state machine object
        2:  304:            QS_FUN_PRE_(t->stateHandler);   // the source state
        2:  305:        QS_END_PRE_()
        4:  306:        QS_MEM_APP();
        -:  307:
        4:  308:        QF_CRIT_EXIT();
        -:  309:    }
        -:  310:    // event bubbled to the 'top' state?
        3:  311:    else if (t == nullptr) {
        3:  312:        QS_CRIT_ENTRY();
        -:  313:        // current state can't be nullptr
        3:  314:        Q_ASSERT_INCRIT(390, s != nullptr);
        -:  315:
        3:  316:        QS_MEM_SYS();
        3:  317:        QS_BEGIN_PRE_(QS_QEP_IGNORED, qsId)
        2:  318:            QS_TIME_PRE_();                 // time stamp
        2:  319:            QS_SIG_PRE_(e->sig);            // the signal of the event
        2:  320:            QS_OBJ_PRE_(this);              // this state machine object
        2:  321:            QS_FUN_PRE_(s->stateHandler);   // the current state
        2:  322:        QS_END_PRE_()
        3:  323:        QS_MEM_APP();
        3:  324:        QS_CRIT_EXIT();
        -:  325:    }
        -:  326:    #endif // Q_SPY
        -:  327:    else {
        -:  328:        // empty
        -:  329:    }
        -:  330:
        -:  331:    #ifndef Q_UNSAFE
       41:  332:    m_temp.uint = ~m_state.uint;
        -:  333:    #endif
       41:  334:}
        -:  335:
        -:  336://${QEP::QMsm::isIn} .........................................................
       11:  337:bool QMsm::isIn(QStateHandler const state) noexcept {
       11:  338:    bool inState = false; // assume that this SM is not in 'state'
        -:  339:
       11:  340:    QMState const *s = m_state.obj;
       11:  341:    std::int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       26:  342:    for (; (s != nullptr) && (lbound > 0); --lbound) {
       23:  343:        if (s->stateHandler == state) { // match found?
        -:  344:            inState = true;
        -:  345:            break;
        -:  346:        }
        -:  347:        else {
       15:  348:            s = s->superstate; // advance to the superstate
        -:  349:        }
        -:  350:    }
        -:  351:
        -:  352:    QF_CRIT_STAT
       11:  353:    QF_CRIT_ENTRY();
      11*:  354:    Q_ENSURE_INCRIT(490, lbound > 0);
       11:  355:    QF_CRIT_EXIT();
        -:  356:
       11:  357:    return inState;
        -:  358:}
        -:  359:
        -:  360://${QEP::QMsm::childStateObj} ................................................
       10:  361:QMState const * QMsm::childStateObj(QMState const * const parent) const noexcept {
       10:  362:    QMState const *child = m_state.obj;
       10:  363:    bool isFound = false; // start with the child not found
       10:  364:    QMState const *s;
        -:  365:
       10:  366:    std::int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       10:  367:    for (s = m_state.obj;
       34:  368:         (s != nullptr) && (lbound > 0);
       24:  369:         s = s->superstate)
        -:  370:    {
       34:  371:        if (s == parent) {
        -:  372:            isFound = true; // child is found
        -:  373:            break;
        -:  374:        }
        -:  375:        else {
       24:  376:            child = s;
        -:  377:        }
       24:  378:        --lbound;
        -:  379:    }
        -:  380:    QF_CRIT_STAT
       10:  381:    QF_CRIT_ENTRY();
      10*:  382:    Q_ENSURE_INCRIT(680, lbound > 0);
       10:  383:    QF_CRIT_EXIT();
        -:  384:
       10:  385:    if (!isFound) { // still not found?
    #####:  386:        lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
    #####:  387:        for (s = m_temp.obj;
    #####:  388:             (s != nullptr) && (lbound > 0);
    #####:  389:             s = s->superstate)
        -:  390:        {
    #####:  391:            if (s == parent) {
        -:  392:                isFound = true; // child is found
        -:  393:                break;
        -:  394:            }
        -:  395:            else {
    #####:  396:                child = s;
        -:  397:            }
    #####:  398:            --lbound;
        -:  399:        }
        -:  400:    }
        -:  401:
       10:  402:    QF_CRIT_ENTRY();
        -:  403:    // NOTE: the following postcondition can only succeed when
        -:  404:    // (lbound > 0), so no extra check is necessary.
      10*:  405:    Q_ENSURE_INCRIT(690, isFound);
       10:  406:    QF_CRIT_EXIT();
        -:  407:
       10:  408:    return child; // return the child
        -:  409:}
        -:  410:
        -:  411://${QEP::QMsm::execTatbl_} ...................................................
       62:  412:QState QMsm::execTatbl_(
        -:  413:    QMTranActTable const * const tatbl,
        -:  414:    std::uint_fast8_t const qsId)
        -:  415:{
        -:  416:    #ifndef Q_SPY
        -:  417:    Q_UNUSED_PAR(qsId);
        -:  418:    #endif
        -:  419:
        -:  420:    QF_CRIT_STAT
       62:  421:    QF_CRIT_ENTRY();
        -:  422:    // precondition:
        -:  423:    // - the tran-action table pointer must not be NULL
      62*:  424:    Q_REQUIRE_INCRIT(700, tatbl != nullptr);
       62:  425:    QF_CRIT_EXIT();
        -:  426:
       62:  427:    QState r = Q_RET_NULL;
       62:  428:    std::int_fast8_t lbound = QMSM_MAX_TRAN_LENGTH_; // fixed upper loop bound
       62:  429:    QActionHandler const *a = &tatbl->act[0];
      198:  430:    for (; (*a != nullptr) && (lbound > 0); ++a) {
      136:  431:        r = (*(*a))(this); // call the action through the 'a' pointer
      136:  432:        --lbound;
        -:  433:    #ifdef Q_SPY
      136:  434:        QS_CRIT_ENTRY();
      136:  435:        QS_MEM_SYS();
      136:  436:        if (r == Q_RET_ENTRY) {
       80:  437:            QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qsId)
       40:  438:                QS_OBJ_PRE_(this); // this state machine object
       40:  439:                QS_FUN_PRE_(m_temp.obj->stateHandler); // entered state
       40:  440:            QS_END_PRE_()
        -:  441:        }
       56:  442:        else if (r == Q_RET_EXIT) {
       38:  443:            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qsId)
       19:  444:                QS_OBJ_PRE_(this); // this state machine object
       19:  445:                QS_FUN_PRE_(m_temp.obj->stateHandler); // exited state
       19:  446:            QS_END_PRE_()
        -:  447:        }
       18:  448:        else if (r == Q_RET_TRAN_INIT) {
       18:  449:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        9:  450:                QS_OBJ_PRE_(this); // this state machine object
        9:  451:                QS_FUN_PRE_(tatbl->target->stateHandler);        // source
        9:  452:                QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
        9:  453:            QS_END_PRE_()
        -:  454:        }
        -:  455:        else {
        -:  456:            // empty
        -:  457:        }
      136:  458:        QS_MEM_APP();
      136:  459:        QS_CRIT_EXIT();
        -:  460:    #endif // Q_SPY
        -:  461:    }
       62:  462:    QF_CRIT_ENTRY();
        -:  463:    // NOTE: the following postcondition can only succeed when
        -:  464:    // (lbound > 0), so no extra check is necessary.
      62*:  465:    Q_ENSURE_INCRIT(790, *a == nullptr);
       62:  466:    QF_CRIT_EXIT();
        -:  467:
       62:  468:    m_state.obj = (r >= Q_RET_TRAN)
       18:  469:        ? m_temp.tatbl->target
        -:  470:        : tatbl->target;
       62:  471:    return r;
        -:  472:}
        -:  473:
        -:  474://${QEP::QMsm::exitToTranSource_} ............................................
       50:  475:void QMsm::exitToTranSource_(
        -:  476:    QMState const * const cs,
        -:  477:    QMState const * const ts,
        -:  478:    std::uint_fast8_t const qsId)
        -:  479:{
        -:  480:    #ifndef Q_SPY
        -:  481:    Q_UNUSED_PAR(qsId);
        -:  482:    #endif
        -:  483:
        -:  484:    QF_CRIT_STAT
        -:  485:
        -:  486:    // exit states from the current state to the tran. source state
       50:  487:    QMState const *s = cs;
       50:  488:    std::int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       80:  489:    for (; (s != ts) && (lbound > 0); --lbound) {
        -:  490:        // exit action provided in state 's'?
       30:  491:        if (s->exitAction != nullptr) {
        -:  492:            // execute the exit action
       30:  493:            static_cast<void>((*s->exitAction)(this));
        -:  494:
       30:  495:            QS_CRIT_ENTRY();
       30:  496:            QS_MEM_SYS();
       30:  497:            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qsId)
       15:  498:                QS_OBJ_PRE_(this);            // this state machine object
       15:  499:                QS_FUN_PRE_(s->stateHandler); // the exited state handler
       15:  500:            QS_END_PRE_()
       30:  501:            QS_MEM_APP();
       30:  502:            QS_CRIT_EXIT();
        -:  503:        }
        -:  504:
       30:  505:        s = s->superstate; // advance to the superstate
        -:  506:    }
       50:  507:    QF_CRIT_ENTRY();
      50*:  508:    Q_ENSURE_INCRIT(890, lbound > 0);
       50:  509:    QF_CRIT_EXIT();
       50:  510:}
        -:  511:
        -:  512://${QEP::QMsm::enterHistory_} ................................................
        8:  513:QState QMsm::enterHistory_(
        -:  514:    QMState const * const hist,
        -:  515:    std::uint_fast8_t const qsId)
        -:  516:{
        -:  517:    #ifndef Q_SPY
        -:  518:    Q_UNUSED_PAR(qsId);
        -:  519:    #endif
        -:  520:
        -:  521:    // record the entry path from current state to history
        8:  522:    QMState const *epath[QMSM_MAX_ENTRY_DEPTH_];
        8:  523:    QMState const *s = hist;
        8:  524:    std::int_fast8_t i = 0; // tran. entry path index
       20:  525:    while ((s != m_state.obj) && (i < (QMSM_MAX_ENTRY_DEPTH_ - 1))) {
       12:  526:        if (s->entryAction != nullptr) {
       12:  527:            epath[i] = s;
       12:  528:            ++i;
        -:  529:        }
       12:  530:        s = s->superstate;
        -:  531:    }
        -:  532:    QF_CRIT_STAT
        8:  533:    QF_CRIT_ENTRY();
       8*:  534:    Q_ASSERT_INCRIT(910, s == m_state.obj);
        8:  535:    QF_CRIT_EXIT();
        -:  536:
        -:  537:    // retrace the entry path in reverse (desired) order...
       20:  538:    while (i > 0) {
       12:  539:        --i;
       12:  540:        (*epath[i]->entryAction)(this); // run entry action in epath[i]
        -:  541:
       12:  542:        QS_CRIT_ENTRY();
       12:  543:        QS_MEM_SYS();
       12:  544:        QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qsId)
        6:  545:            QS_OBJ_PRE_(this);
        6:  546:            QS_FUN_PRE_(epath[i]->stateHandler); // entered state handler
        6:  547:        QS_END_PRE_()
       12:  548:        QS_MEM_APP();
       12:  549:        QS_CRIT_EXIT();
        -:  550:    }
        -:  551:
        8:  552:    m_state.obj = hist; // set current state to the tran. target
        -:  553:
        -:  554:    // initial tran. present?
        8:  555:    QState r;
        8:  556:    if (hist->initAction != nullptr) {
        4:  557:        r = (*hist->initAction)(this); // execute the tran. action
        4:  558:        QS_CRIT_ENTRY();
        4:  559:        QS_MEM_SYS();
        4:  560:        QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        2:  561:            QS_OBJ_PRE_(this); // this state machine object
        2:  562:            QS_FUN_PRE_(hist->stateHandler);                 // source
        2:  563:            QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
        2:  564:        QS_END_PRE_()
        4:  565:        QS_MEM_APP();
        4:  566:        QS_CRIT_EXIT();
        -:  567:    }
        -:  568:    else {
        -:  569:        r = Q_RET_NULL;
        -:  570:    }
        -:  571:
        8:  572:    return r;
        -:  573:}
        -:  574:
        -:  575://${QEP::QMsm::topQMState} ...................................................
    #####:  576:QMState const * QMsm::topQMState() const noexcept {
    #####:  577:    return &l_msm_top_s;
        -:  578:}
        -:  579:
        -:  580:} // namespace QP
        -:  581://$enddef${QEP::QMsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
